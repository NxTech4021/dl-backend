
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String             @id @default(cuid())
  name                String
  email               String             @unique
  emailVerified       Boolean            @default(false)
  image               String?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  displayUsername     String?
  username            String             @unique
  role                Role               @default(USER)
  dateOfBirth         DateTime?
  gender              String?
  area                String?
  completedOnboarding Boolean            @default(false)
  lastActivityCheck   DateTime?
  lastLogin           DateTime?
  status              String             @default("active")
  bio                 String?
  phoneNumber         String?
  admin               Admin?
 
  achievements        UserAchievement[]
  accounts            Account[]
  sessions            Session[]
  seasonMemberships   SeasonMembership[]
  leagueMemberships   LeagueMembership[]
  matchParticipants   MatchParticipant[]
  processedRequests     WithdrawalRequest[] @relation("ProcessedByAdmin")


  @@index([email])
  @@index([username])
  @@index([status])
  @@index([completedOnboarding])
  @@index([createdAt])
  @@map("user")
}

model Admin {
  id        String            @id @default(cuid())
  userId    String?           @unique
  status    AdminStatus       @default(PENDING)
  invitedBy String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  user      User?             @relation(fields: [userId], references: [id])
  invite    AdminInviteToken?

  leagues   League[]      
  company   Company[] 
  sponsor   Sponsorship[] 
  leagueInvites LeagueInvite[]
}

model AdminInviteToken {
  id        String   @id @default(cuid())
  adminId   String   @unique
  email     String
  token     String   @unique
  status    String   @default("PENDING")
  createdAt DateTime @default(now())
  expiresAt DateTime
  admin     Admin    @relation(fields: [adminId], references: [id])
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("account")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("session")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String   @unique
  status     String   @default("PENDING")
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

model QuestionnaireResponse {
  id          Int                  @id @default(autoincrement())
  userId      String
  sport       String
  qVersion    Int
  qHash       String
  answersJson Json
  startedAt   DateTime             @default(now())
  completedAt DateTime?
  result      InitialRatingResult?

  @@index([userId])
  @@index([sport, qVersion])
  @@index([qHash])
}

model InitialRatingResult {
  id         Int                   @id @default(autoincrement())
  responseId Int                   @unique
  source     String
  singles    Int?
  doubles    Int?
  rd         Int?
  confidence String?
  detail     Json?
  createdAt  DateTime              @default(now())
  response   QuestionnaireResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)
}

model League {
  id            String        @id @default(cuid())
  name          String        @db.VarChar(255)
  location      String?
  description   String?

  status        Statuses       @default(UPCOMING)
  sportType     SportType
  joinType      LeagueType?   
  gameType      GameType

  createdById      String?    
  createdBy        Admin?       @relation(fields: [createdById], references: [id])

  seasons       Season[]
  sponsorships  Sponsorship[]
  memberships   LeagueMembership[] 
  categories    Category []
  invites       LeagueInvite[]

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  @@index([location])
  @@index([status])
}


model LeagueMembership {
  id        String   @id @default(cuid())
  userId    String
  leagueId  String
  joinedAt  DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
  league    League   @relation(fields: [leagueId], references: [id])

  @@unique([userId, leagueId])
  @@index([leagueId])
  @@index([userId])
}

model LeagueInvite {
  id          String   @id @default(cuid())
  leagueId    String
  email       String
  token       String   @unique
  invitedById String?  
  accepted    Boolean  @default(false)
  createdAt   DateTime @default(now())

  league      League   @relation(fields: [leagueId], references: [id])
  invitedBy   Admin?    @relation(fields: [invitedById], references: [id])

  @@index([leagueId])
  @@index([email])
}

model Category {
  id                  String              @id @default(cuid())  // 'category_id'
  leagueId            String?            
  name                String?              @db.VarChar(255)    
  
  // Restrictions and Format
  genderRestriction   GenderRestriction   @default(OPEN)       // 'gender_restriction' enum
  matchFormat         String?                                  // 'match_format' e.g., Best of 3 sets
  maxPlayers          Int?                                     // 'max_players' (for individual/singles)
  maxTeams            Int?                                     // 'max_teams' (for doubles/team events)
  

  isActive            Boolean             @default(true)       // 'is_active'
  categoryOrder       Int                 @default(0)          // 'category_order' for display

  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
 
  league              League?              @relation(fields: [leagueId], references: [id])
  seasons             Season[] 

  //seasonCategories    SeasonCategory[]
  
  // Indexes for efficient querying
  
  @@index([leagueId])
  @@index([isActive])
}

//Not using now 
model Company {
  id              String        @id @default(cuid()) 
  name            String        @db.VarChar(255)
  contactEmail    String?       @unique
  website         String?
  logoUrl         String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  createdById     String?       // Admin who created the company
  createdBy       Admin?        @relation(fields: [createdById], references: [id])
  sponsorshipDeals Sponsorship[] 
  
  @@map("company")
}

model Sponsorship {
  id                      String        @id @default(cuid()) 
  leagueId                String?     
  companyId               String?      
  packageTier             TierType      
  contractAmount          Decimal?       @db.Decimal(10, 2) 
  sponsorRevenue          Decimal?      @db.Decimal(10, 2) 
  sponsoredName           String?       
  createdById             String?
  createdAt               DateTime      @default(now())
  updatedAt               DateTime      @updatedAt

  // Relationships
  league         League?       @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  company        Company?      @relation(fields: [companyId], references: [id])
  createdBy      Admin?          @relation(fields: [createdById], references: [id])

  @@unique([leagueId, companyId, packageTier])
  @@index([leagueId])
  @@index([companyId])
  @@map("sponsorship")
}

model Season {
  id              String         @id @default(cuid())
  name            String        
  startDate       DateTime?
  endDate         DateTime?
  regiDeadline    DateTime?
  entryFee        Decimal        @db.Decimal(10, 2) 
  description     String?
  sportType       String? 
  seasonType      GameType          
  registeredUserCount   Int               @default(0)

  //Bools
  status          SeasonStatus   @default(UPCOMING)    
  isActive              Boolean           @default(false)
  paymentRequired       Boolean           @default(false)
  promoCodeSupported    Boolean           @default(false)
  withdrawalEnabled     Boolean           @default(false)

  
  //Relations
  divisions       Division[]
  memberships     SeasonMembership[]
  promoCodes            PromoCode[]       @relation("SeasonPromoCodes") 
  withdrawalRequests    WithdrawalRequest[] 

  leagueId        String
  league          League    @relation(fields: [leagueId], references: [id])

  categoryId      String
  category        Category  @relation(fields: [categoryId], references: [id])
  
  waitlistId             String?
   waitlist              Waitlist?         @relation
  
 
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  @@index([sportType])
  @@index([status])
  @@index([isActive])
}

model Waitlist {
  id                 String                 @id @default(cuid())
  seasonId              String              @unique
  season                Season              @relation(fields: [seasonId], references: [id])
  enabled            Boolean                @default(false)
  maxParticipants    Int?
  waitlistedUsers     WaitlistUser[]

  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
}

model WaitlistUser {
  id                 String                 @id @default(cuid())
  waitlistId         String
  userId             String
  waitlistDate       DateTime               @default(now())
  promotedToRegistered Boolean              @default(false)

  waitlist           Waitlist               @relation(fields: [waitlistId], references: [id])
  
  @@unique([waitlistId, userId])
  @@index([userId])
}

model PromoCode {
  id              String            @id @default(cuid())
  code            String            @unique // e.g., "OFF50"
  description     String?           // For internal clarity
  discountValue   Decimal           @db.Decimal(10, 2) // e.g., 50.00 (dollars or percentage)
  isPercentage    Boolean           @default(false) // True for %, false for fixed amount
  isActive        Boolean           @default(true)
  expiresAt       DateTime?         // Optional expiration date

  // Many-to-Many relation to Season
  seasons         Season[]          @relation("SeasonPromoCodes")

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
}

model WithdrawalRequest {
  id                    String              @id @default(cuid())
  userId                String
  reason                String
  requestDate           DateTime            @default(now())
  status                WithdrawalStatus    @default(PENDING)
  processedByAdminId String? 

  processedByAdmin      User?               @relation("ProcessedByAdmin", fields: [processedByAdminId], references: [id])
  seasonId              String
  season                Season              @relation(fields: [seasonId], references: [id])

  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
}

model Division {
  id              String         @id @default(cuid())
  seasonId        String
  name            String         
  description     String?
  threshold       Int?           
  
  // Settings 
  divisionLevel   DivisionLevel     
  gameType        GameType          
  category          Gender

  maxSingles        Int?
  maxDoublesTeams   Int?

  isActive        Boolean      @default(true)


  // Relations
  season          Season         @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  memberships     SeasonMembership[]
  matches         Match[] 
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  @@unique([seasonId, name]) 
  @@index([seasonId])
}



model SeasonMembership {
  id              String         @id @default(cuid())
  userId          String
  seasonId        String
  divisionId      String
  status          String         @default("PENDING") // 'PENDING' | 'ACTIVE' | 'INACTIVE' | 'FLAGGED' | 'REMOVED'
  joinedAt        DateTime       @default(now())
  withdrawalReason String?        // For handling "View Withdrawal Request"
  
  // Relations
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  season           Season   @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division         Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([userId, seasonId, divisionId])
  @@index([userId])
  @@index([seasonId])
  @@index([divisionId, status])
}

model Match {
  id            String      @id @default(cuid())
  divisionId    String?
  sport         String
  matchType     String
  playerScore   Int?
  opponentScore Int?
  outcome       String?
  matchDate     DateTime    @default(now())
  location      String?
  notes         String?
  duration      Int?

  division      Division?   @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  participants  MatchParticipant[]
  stats         MatchStats?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([divisionId])
  @@index([sport])
  @@index([matchDate])
}

model MatchParticipant {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  isStarter Boolean  @default(true)
  team      String?
  createdAt DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@index([userId])
  @@index([matchId])
}

model MatchStats {
  id                     String   @id @default(cuid())
  matchId                String   @unique
  playerAces             Int?
  playerUnforcedErrors   Int?
  playerWinners          Int?
  playerDoubleFaults     Int?
  opponentAces           Int?
  opponentUnforcedErrors Int?
  opponentWinners        Int?
  opponentDoubleFaults   Int?
  rallyCount             Int?
  longestRally           Int?
  breakPointsConverted   Int?
  breakPointsTotal       Int?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  match                  Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
}

model Achievement {
  id               String            @id @default(cuid())
  title            String
  description      String
  icon             String?
  category         String
  requirement      Json?
  points           Int               @default(0)
  isActive         Boolean           @default(true)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  userAchievements UserAchievement[]

  @@index([category])
  @@index([isActive])
}

model UserAchievement {
  id            String      @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime    @default(now())
  progress      Json?
  isCompleted   Boolean     @default(true)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([achievementId])
}

enum Role {
  USER
  ADMIN
  SUPERADMIN
}

enum AdminStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum SeasonStatus {
  UPCOMING
  ACTIVE
  FINISHED
  CANCELLED
}

enum GenderRestriction {
  MALE
  FEMALE
  MIXED
  OPEN
}

enum MembershipStatus {
  PENDING
  ACTIVE
  FLAGGED
  INACTIVE
  REMOVED
}

enum Statuses {
  ACTIVE
  INACTIVE
  SUSPENDED
  UPCOMING
  ONGOING
  FINISHED
  CANCELLED
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum LeagueType{
  OPEN
  INVITE_ONLY
  MANUAL
}

enum DivisionLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum GameType {
  SINGLES
  DOUBLES
}

enum SportType {
  PADDLE
  PICKLEBALL
  TENNIS
}

enum Gender {
  MALE
  FEMALE
  MIXED
}

enum TierType{
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

