generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String    @id @default(cuid())
  name                String
  email               String    @unique
  emailVerified       Boolean   @default(false)
  image               String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  displayUsername     String?
  username            String    @unique
  role                Role      @default(USER)
  dateOfBirth         DateTime?
  gender              String?
  area                String?
  completedOnboarding Boolean   @default(false)
  lastActivityCheck   DateTime?
  lastLogin           DateTime?
  status              UserStatus @default(ACTIVE)
  bio                 String?
  phoneNumber         String?
  admin               Admin?

  achievements      UserAchievement[]
  accounts          Account[]
  sessions          Session[]
  seasonMemberships SeasonMembership[]
  matchParticipants MatchParticipant[]
  processedRequests WithdrawalRequest[] @relation("ProcessedByAdmin")

  divisionAssignments DivisionAssignment[] @relation("DivisionAssignments")

  // Pairing & Friendship Relations
  sentFriendRequests        Friendship[]       @relation("SentFriendRequests")
  receivedFriendRequests    Friendship[]       @relation("ReceivedFriendRequests")
  sentPairRequests          PairRequest[]      @relation("SentPairRequests")
  receivedPairRequests      PairRequest[]      @relation("ReceivedPairRequests")
  captainPartnerships       Partnership[]      @relation("PartnershipCaptain")
  partnerPartnerships       Partnership[]      @relation("PartnershipPartner")
  sentSeasonInvitations     SeasonInvitation[] @relation("SentSeasonInvitations")
  receivedSeasonInvitations SeasonInvitation[] @relation("ReceivedSeasonInvitations")

  // Favorite relations
  favoritesMade     Favorite[] @relation("UserFavorites")
  favoritedByOthers Favorite[] @relation("FavoritedUser")

  //Thread relations
  userThreads UserThread[]
  messages    Message[]

  // Questionnaire relations
  questionnaireResponses QuestionnaireResponse[]

  // Notification relations
  notifications     Notification[]
  userNotifications UserNotification[]

  // Admin-focused match management relations
  raisedDisputes     MatchDispute[]   @relation("RaisedDisputes")
  disputeComments    DisputeComment[] @relation("DisputeComments")
  defaultedMatches   MatchWalkover[]  @relation("DefaultedMatches")
  walkoverWins       MatchWalkover[]  @relation("WalkoverWins")
  reportedWalkovers  MatchWalkover[]  @relation("ReportedWalkovers")
  confirmedWalkovers MatchWalkover[]  @relation("ConfirmedWalkovers")
  penalties          PlayerPenalty[]  @relation("UserPenalties")

  // Rating system relations
  playerRatings      PlayerRating[]
  divisionStandings  DivisionStanding[]

  // Inactivity tracking
  lastMatchDate         DateTime?
  inactivityWarningAt   DateTime?
  markedInactiveAt      DateTime?
  inactivityExempt      Boolean   @default(false)
  statusChanges         PlayerStatusChange[]

  // Bug tracking relations
  bugReports            BugReport[]       @relation("BugReporter")
  bugComments           BugComment[]      @relation("BugCommentAuthor")
  bugStatusChanges      BugStatusChange[] @relation("BugStatusChanger")

  @@index([email])
  @@index([lastMatchDate])
  @@index([username])
  @@index([status])
  @@index([completedOnboarding])
  @@index([createdAt])
  @@map("user")
}

model Admin {
  id        String            @id @default(cuid())
  userId    String?           @unique
  status    AdminStatus       @default(PENDING)
  invitedBy String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  user      User?             @relation(fields: [userId], references: [id])
  invite    AdminInviteToken?

  // Relations
  leagues             League[]
  sponsorships        Sponsorship[]        @relation("SponsorshipCreatedBy")
  divisionsCreated    Division[]           @relation("DivisionCreatedBy")
  divisionsUpdated    Division[]           @relation("DivisionUpdatedBy")
  divisionAssignments DivisionAssignment[] @relation("AssignmentsByAdmin")

  // Admin-focused match management relations
  reviewedDisputes  MatchDispute[]     @relation("ReviewedDisputes")
  resolvedDisputes  MatchDispute[]     @relation("ResolvedDisputes")
  disputeNotes      DisputeAdminNote[] @relation("DisputeNotes")
  verifiedWalkovers MatchWalkover[]    @relation("VerifiedWalkovers")
  issuedPenalties   PlayerPenalty[]    @relation("IssuedPenalties")
  resolvedAppeals   PlayerPenalty[]    @relation("ResolvedAppeals")
  adminMatchActions MatchAdminAction[] @relation("AdminMatchActions")

  // Rating system relations
  ratingAdjustments     RatingAdjustment[]    @relation("RatingAdjustments")
  ratingParameters      RatingParameters[]    @relation("RatingParametersCreated")
  ratingRecalculations  RatingRecalculation[] @relation("RatingRecalculations")
  seasonsLocked         SeasonLock[]          @relation("SeasonLockedBy")
  seasonsOverridden     SeasonLock[]          @relation("SeasonOverrideBy")

  // Inactivity system relations
  inactivitySettingsUpdated InactivitySettings[]  @relation("InactivitySettingsUpdated")
  statusChangesTriggered    PlayerStatusChange[]  @relation("StatusChangesTriggered")

  // Bug tracking relations
  assignedBugs              BugReport[]           @relation("BugAssignee")
  resolvedBugs              BugReport[]           @relation("BugResolver")
  bugDefaultSettings        BugReportSettings[]   @relation("BugDefaultAssignee")
}

model AdminInviteToken {
  id        String   @id @default(cuid())
  adminId   String   @unique
  email     String
  token     String   @unique
  status    String   @default("PENDING")
  createdAt DateTime @default(now())
  expiresAt DateTime
  admin     Admin    @relation(fields: [adminId], references: [id])
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("account")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("session")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String   @unique
  status     String   @default("PENDING")
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

model QuestionnaireResponse {
  id          Int                  @id @default(autoincrement())
  userId      String
  sport       String
  qVersion    Int
  qHash       String
  answersJson Json
  startedAt   DateTime             @default(now())
  completedAt DateTime?
  result      InitialRatingResult?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sport, qVersion])
  @@index([qHash])
}

model InitialRatingResult {
  id         Int                   @id @default(autoincrement())
  responseId Int                   @unique
  source     String
  singles    Int?
  doubles    Int?
  rd         Int?
  confidence String?
  detail     Json?
  createdAt  DateTime              @default(now())
  response   QuestionnaireResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)
}

model League {
  id          String  @id @default(cuid())
  name        String  @db.VarChar(255)
  location    String?
  description String?

  status    Statuses  @default(UPCOMING)
  sportType SportType
  gameType  GameType

  createdById String?
  createdBy   Admin?  @relation(fields: [createdById], references: [id])

  seasons      Season[]      @relation("LeagueToSeason")
  sponsorships Sponsorship[]
  divisions    Division[]
  matches      Match[]       @relation("LeagueMatches")

  // Rating system relations
  ratingParameters RatingParameters[]

  // Inactivity system relations
  inactivitySettings InactivitySettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([location])
  @@index([status])
}

model Category {
  id   String  @id @default(cuid())
  name String? @db.VarChar(255)

  // Restrictions and Format
  genderRestriction GenderRestriction @default(OPEN)
  matchFormat       String? // e.g., Best of 3 sets
  gameType          GameType?
  genderCategory    GenderType?
  isActive          Boolean           @default(true)
  categoryOrder     Int               @default(0)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  seasons Season[]

  @@index([isActive])
}

model Sponsorship {
  id             String   @id @default(cuid())
  packageTier    TierType
  contractAmount Decimal? @db.Decimal(10, 2)
  sponsorRevenue Decimal? @db.Decimal(10, 2)
  sponsoredName  String?
  createdById    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships
  leagues   League[]
  createdBy Admin?     @relation("SponsorshipCreatedBy", fields: [createdById], references: [id])
  divisions Division[] @relation("DivisionSponsor")
  seasons   Season[]   @relation("SeasonSponsor")

  @@map("sponsorship")
}

model Season {
  id                  String    @id @default(cuid())
  name                String
  startDate           DateTime?
  endDate             DateTime?
  regiDeadline        DateTime?
  entryFee            Decimal   @db.Decimal(10, 2)
  description         String?
  registeredUserCount Int       @default(0)

  //Bools
  status             SeasonStatus @default(UPCOMING)
  isActive           Boolean      @default(false)
  paymentRequired    Boolean      @default(false)
  promoCodeSupported Boolean      @default(false)
  withdrawalEnabled  Boolean      @default(false)

  //Relations
  divisions          Division[]
  memberships        SeasonMembership[]
  promoCodes         PromoCode[]         @relation("SeasonPromoCodes")
  withdrawalRequests WithdrawalRequest[]

  // Pairing Relations
  pairRequests      PairRequest[]
  partnerships      Partnership[]
  seasonInvitations SeasonInvitation[]

  leagues League[] @relation("LeagueToSeason")

  categoryId String?
  category   Category?    @relation(fields: [categoryId], references: [id])
  sponsorId  String?
  sponsor    Sponsorship? @relation("SeasonSponsor", fields: [sponsorId], references: [id], onDelete: SetNull)

  notifications Notification[]

  waitlistId String?
  waitlist   Waitlist? @relation

  // Rating system relations
  playerRatings     PlayerRating[]
  divisionStandings DivisionStanding[]
  ratingParameters  RatingParameters[]
  seasonLock        SeasonLock?
  matches           Match[]            @relation("SeasonMatches")

  // Inactivity system relations
  inactivitySettings InactivitySettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([isActive])
  @@index([sponsorId])
}

model Waitlist {
  id              String         @id @default(cuid())
  seasonId        String         @unique
  season          Season         @relation(fields: [seasonId], references: [id])
  enabled         Boolean        @default(false)
  maxParticipants Int?
  waitlistedUsers WaitlistUser[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WaitlistUser {
  id                   String   @id @default(cuid())
  waitlistId           String
  userId               String
  waitlistDate         DateTime @default(now())
  promotedToRegistered Boolean  @default(false)

  waitlist Waitlist @relation(fields: [waitlistId], references: [id])

  @@unique([waitlistId, userId])
  @@index([waitlistId])
  @@index([userId])
}

model PromoCode {
  id            String    @id @default(cuid())
  code          String    @unique
  description   String?
  discountValue Decimal   @db.Decimal(10, 2)
  isPercentage  Boolean   @default(false) // True for %, false for fixed amount
  isActive      Boolean   @default(true)
  expiresAt     DateTime?

  seasons Season[] @relation("SeasonPromoCodes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WithdrawalRequest {
  id                 String           @id @default(cuid())
  userId             String
  reason             String
  requestDate        DateTime         @default(now())
  status             WithdrawalStatus @default(PENDING)
  processedByAdminId String?
  partnershipId      String? // For partner change requests

  processedByAdmin User?          @relation("ProcessedByAdmin", fields: [processedByAdminId], references: [id])
  seasonId         String
  season           Season         @relation(fields: [seasonId], references: [id])
  partnership      Partnership?   @relation(fields: [partnershipId], references: [id])
  notifications    Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Division {
  id             String         @id @default(cuid())
  name           String
  description    String?
  level          DivisionLevel?
  gameType       GameType
  genderCategory GenderType?

  // capacities
  maxSinglesPlayers Int?
  maxDoublesTeams   Int?

  // denormalized counts
  currentSinglesCount Int? @default(0)
  currentDoublesCount Int? @default(0)

  autoAssignmentEnabled Boolean @default(false)
  isActiveDivision      Boolean @default(true)
  pointsThreshold       Int?

  // Sponsorship fields
  divisionSponsorId     String? // division_sponsor_id
  divisionSponsor       Sponsorship? @relation("DivisionSponsor", fields: [divisionSponsorId], references: [id], onDelete: SetNull)
  sponsoredDivisionName String? // sponsored_division_name
  prizePoolTotal        Decimal?     @db.Decimal(10, 2) // prize_pool_total

  // audit â€” Admin FKs
  createdByAdminId     String?
  createdByAdmin       Admin?  @relation("DivisionCreatedBy", fields: [createdByAdminId], references: [id], onDelete: SetNull)
  lastUpdatedByAdminId String?
  lastUpdatedByAdmin   Admin?  @relation("DivisionUpdatedBy", fields: [lastUpdatedByAdminId], references: [id], onDelete: SetNull)

  // Relations
  matches           Match[]
  assignments       DivisionAssignment[] // Player assignments tracking
  seasonMemberships SeasonMembership[]   @relation("SeasonMembershipDivision")
  seasonId          String
  season            Season               @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  leagueId          String
  league            League               @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  threads           Thread[]             @relation("DivisionThreads")
  notifications     Notification[]

  // Pairing Relations
  partnerships Partnership[]

  // Rating system relations
  playerRatings     PlayerRating[]
  divisionStandings DivisionStanding[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([seasonId, name])
  @@index([seasonId])
  @@index([leagueId])
  @@index([isActiveDivision])
  @@index([divisionSponsorId])
  @@map("division")
}

model SeasonMembership {
  id               String        @id @default(cuid())
  userId           String
  seasonId         String
  divisionId       String?
  status           MembershipStatus @default(PENDING)
  joinedAt         DateTime         @default(now())
  withdrawalReason String? // For handling "View Withdrawal Request"
  paymentStatus    PaymentStatus @default(PENDING)

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  season   Season    @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division Division? @relation("SeasonMembershipDivision", fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([userId, seasonId, divisionId])
  @@index([userId])
  @@index([seasonId])
  @@index([divisionId, status])
}

model DivisionAssignment {
  id                String   @id @default(cuid())
  divisionId        String
  userId            String
  assignedBy        String? // Admin ID who made the assignment
  assignedAt        DateTime @default(now())
  reassignmentCount Int      @default(0) // Track how many times player was moved
  notes             String? // Admin notes for assignment

  // Relations
  division        Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  user            User     @relation("DivisionAssignments", fields: [userId], references: [id], onDelete: Cascade)
  assignedByAdmin Admin?   @relation("AssignmentsByAdmin", fields: [assignedBy], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([divisionId, userId])
  @@index([divisionId])
  @@index([userId])
  @@index([assignedBy])
  @@map("division_assignment")
}

model Match {
  id            String   @id @default(cuid())
  divisionId    String?
  leagueId      String?
  seasonId      String?
  sport         String
  matchType     String
  playerScore   Int?
  opponentScore Int?
  outcome       String?
  matchDate     DateTime @default(now())
  location      String?
  notes         String?
  duration      Int?

  // Enhanced fields for admin management
  status         MatchStatus @default(SCHEDULED)
  isWalkover     Boolean     @default(false)
  isDisputed     Boolean     @default(false)
  adminNotes     String?

  // Scheduling fields
  scheduledStartTime      DateTime?
  actualStartTime         DateTime?

  // Cancellation tracking
  cancellationRequestedAt DateTime?
  isLateCancellation      Boolean   @default(false)
  cancellationReason      String?

  // Reschedule tracking
  rescheduledFromId       String?   @unique
  rescheduleCount         Int       @default(0)

  // Standard walkover scores
  walkoverScore           Json?

  division      Division?          @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  league        League?            @relation("LeagueMatches", fields: [leagueId], references: [id], onDelete: SetNull)
  season        Season?            @relation("SeasonMatches", fields: [seasonId], references: [id], onDelete: SetNull)
  participants  MatchParticipant[]
  stats         MatchStats?
  notifications Notification[]

  // Admin-focused relations
  disputes     MatchDispute[]
  walkover     MatchWalkover?
  adminActions MatchAdminAction[]
  penalties    PlayerPenalty[]    @relation("MatchPenalties")

  // Rating system relations
  scores        MatchScore[]
  ratingHistory RatingHistory[]

  // Inactivity system relations
  statusChanges PlayerStatusChange[]

  // Reschedule relation
  rescheduledFrom Match? @relation("Reschedule", fields: [rescheduledFromId], references: [id])
  rescheduledTo   Match? @relation("Reschedule")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([divisionId])
  @@index([leagueId])
  @@index([seasonId])
  @@index([sport])
  @@index([matchDate])
  @@index([status])
  @@index([isDisputed])
  @@index([matchType])
  @@index([scheduledStartTime])
  @@index([isLateCancellation])
}

//TO DO - use this and link with seasonmembership
model MatchParticipant {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  isStarter Boolean  @default(true)
  team      String?
  createdAt DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@index([userId])
  @@index([matchId])
}

model MatchStats {
  id                     String   @id @default(cuid())
  matchId                String   @unique
  playerAces             Int?
  playerUnforcedErrors   Int?
  playerWinners          Int?
  playerDoubleFaults     Int?
  opponentAces           Int?
  opponentUnforcedErrors Int?
  opponentWinners        Int?
  opponentDoubleFaults   Int?
  rallyCount             Int?
  longestRally           Int?
  breakPointsConverted   Int?
  breakPointsTotal       Int?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  match                  Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
}

// =============================================
// ADMIN-FOCUSED MATCH MANAGEMENT MODELS
// =============================================

model MatchDispute {
  id              String          @id @default(cuid())
  matchId         String          @unique
  raisedByUserId  String
  disputeCategory DisputeCategory
  disputeComment  String
  disputerScore   Json?
  evidenceUrl     String?
  submittedAt     DateTime        @default(now())

  // Admin resolution fields
  adminResolution   String?
  resolutionAction  DisputeResolutionAction?
  finalScore        Json?
  resolvedAt        DateTime?
  status            DisputeStatus            @default(OPEN)
  priority          DisputePriority          @default(NORMAL)
  flaggedForReview  Boolean                  @default(false)
  reviewedByAdminId String?
  resolvedByAdminId String?

  // Relations
  match           Match              @relation(fields: [matchId], references: [id], onDelete: Cascade)
  raisedByUser    User               @relation("RaisedDisputes", fields: [raisedByUserId], references: [id])
  reviewedByAdmin Admin?             @relation("ReviewedDisputes", fields: [reviewedByAdminId], references: [id])
  resolvedByAdmin Admin?             @relation("ResolvedDisputes", fields: [resolvedByAdminId], references: [id])
  adminNotes      DisputeAdminNote[]
  comments        DisputeComment[]
  penalties       PlayerPenalty[]    @relation("DisputePenalties")

  @@index([matchId])
  @@index([raisedByUserId])
  @@index([status])
  @@index([priority])
  @@index([reviewedByAdminId])
  @@map("match_dispute")
}

model DisputeAdminNote {
  id             String   @id @default(cuid())
  disputeId      String
  adminId        String
  note           String
  isInternalOnly Boolean  @default(true)
  createdAt      DateTime @default(now())

  dispute MatchDispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  admin   Admin        @relation("DisputeNotes", fields: [adminId], references: [id])

  @@index([disputeId, createdAt(sort: Desc)])
  @@map("dispute_admin_note")
}

model DisputeComment {
  id          String   @id @default(cuid())
  disputeId   String
  senderId    String
  comment     String
  attachments Json?
  createdAt   DateTime @default(now())

  dispute MatchDispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender  User         @relation("DisputeComments", fields: [senderId], references: [id])

  @@index([disputeId, createdAt(sort: Asc)])
  @@map("dispute_comment")
}

model MatchWalkover {
  id                   String         @id @default(cuid())
  matchId              String         @unique
  walkoverFlag         Boolean        @default(true)
  walkoverReason       WalkoverReason
  walkoverReasonDetail String?
  defaultingPlayerId   String
  winningPlayerId      String
  reportedBy           String
  confirmedBy          String?
  adminVerified        Boolean        @default(false)
  adminVerifiedBy      String?
  adminVerifiedAt      DateTime?
  penaltyApplied       Boolean        @default(false)
  penaltyType          PenaltyType?
  penaltyDetails       String?
  penaltyId            String?
  createdAt            DateTime       @default(now())

  match            Match          @relation(fields: [matchId], references: [id], onDelete: Cascade)
  defaultingPlayer User           @relation("DefaultedMatches", fields: [defaultingPlayerId], references: [id])
  winningPlayer    User           @relation("WalkoverWins", fields: [winningPlayerId], references: [id])
  reporter         User           @relation("ReportedWalkovers", fields: [reportedBy], references: [id])
  confirmer        User?          @relation("ConfirmedWalkovers", fields: [confirmedBy], references: [id])
  verifiedByAdmin  Admin?         @relation("VerifiedWalkovers", fields: [adminVerifiedBy], references: [id])
  penalty          PlayerPenalty? @relation(fields: [penaltyId], references: [id])

  @@index([matchId])
  @@index([defaultingPlayerId])
  @@index([winningPlayerId])
  @@index([adminVerified])
  @@map("match_walkover")
}

model PlayerPenalty {
  id                    String          @id @default(cuid())
  userId                String
  penaltyType           PenaltyType
  severity              PenaltySeverity
  relatedMatchId        String?
  relatedDisputeId      String?
  pointsDeducted        Int?
  suspensionDays        Int?
  suspensionStartDate   DateTime?
  suspensionEndDate     DateTime?
  issuedByAdminId       String
  reason                String
  evidenceUrl           String?
  status                PenaltyStatus   @default(ACTIVE)
  appealSubmittedAt     DateTime?
  appealReason          String?
  appealResolvedBy      String?
  appealResolvedAt      DateTime?
  appealResolutionNotes String?
  expiresAt             DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  user                  User            @relation("UserPenalties", fields: [userId], references: [id])
  relatedMatch          Match?          @relation("MatchPenalties", fields: [relatedMatchId], references: [id])
  relatedDispute        MatchDispute?   @relation("DisputePenalties", fields: [relatedDisputeId], references: [id])
  issuedByAdmin         Admin           @relation("IssuedPenalties", fields: [issuedByAdminId], references: [id])
  appealResolvedByAdmin Admin?          @relation("ResolvedAppeals", fields: [appealResolvedBy], references: [id])
  walkovers             MatchWalkover[]

  @@index([userId, status])
  @@index([penaltyType])
  @@index([status])
  @@index([issuedByAdminId])
  @@index([expiresAt])
  @@map("player_penalty")
}

model MatchAdminAction {
  id                     String               @id @default(cuid())
  matchId                String
  adminId                String
  actionType             MatchAdminActionType
  oldValue               Json?
  newValue               Json?
  reason                 String
  affectedUserIds        Json?
  triggeredRecalculation Boolean              @default(false)
  recalculationDetails   Json?
  notifiedUsers          Json?
  ipAddress              String?
  createdAt              DateTime             @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  admin Admin @relation("AdminMatchActions", fields: [adminId], references: [id])

  @@index([matchId, createdAt(sort: Desc)])
  @@index([adminId, createdAt(sort: Desc)])
  @@index([actionType])
  @@map("match_admin_action")
}

// =============================================
// END ADMIN-FOCUSED MATCH MANAGEMENT MODELS
// =============================================

// =============================================
// RATING SYSTEM MODELS
// =============================================

model PlayerRating {
  id              String    @id @default(cuid())
  userId          String
  seasonId        String
  divisionId      String?
  sport           SportType
  gameType        GameType

  // Core rating fields
  currentRating   Int
  ratingDeviation Int?
  volatility      Float?

  // Status
  isProvisional   Boolean   @default(true)
  matchesPlayed   Int       @default(0)

  // Tracking
  lastMatchId     String?
  lastUpdatedAt   DateTime  @updatedAt
  peakRating      Int?
  peakRatingDate  DateTime?
  lowestRating    Int?

  createdAt       DateTime  @default(now())

  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  season          Season    @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division        Division? @relation(fields: [divisionId], references: [id], onDelete: SetNull)
  history         RatingHistory[]
  adjustments     RatingAdjustment[]

  @@unique([userId, seasonId, gameType])
  @@index([seasonId, divisionId])
  @@index([currentRating])
  @@index([isProvisional])
  @@index([userId])
  @@map("player_rating")
}

model RatingHistory {
  id              String              @id @default(cuid())
  playerRatingId  String
  matchId         String?

  // Rating change
  ratingBefore    Int
  ratingAfter     Int
  delta           Int

  // RD change (for Glicko)
  rdBefore        Int?
  rdAfter         Int?

  // Reason
  reason          RatingChangeReason
  notes           String?

  createdAt       DateTime            @default(now())

  // Relations
  playerRating    PlayerRating        @relation(fields: [playerRatingId], references: [id], onDelete: Cascade)
  match           Match?              @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([playerRatingId, createdAt(sort: Desc)])
  @@index([matchId])
  @@map("rating_history")
}

model MatchScore {
  id              String   @id @default(cuid())
  matchId         String
  setNumber       Int

  // Scores per side
  player1Games    Int
  player2Games    Int

  // Tiebreak details
  hasTiebreak     Boolean  @default(false)
  player1Tiebreak Int?
  player2Tiebreak Int?

  createdAt       DateTime @default(now())

  match           Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, setNumber])
  @@index([matchId])
  @@map("match_score")
}

model DivisionStanding {
  id                  String   @id @default(cuid())
  divisionId          String
  seasonId            String

  // Player or Partnership
  userId              String?
  partnershipId       String?

  // Core standings
  rank                Int
  wins                Int      @default(0)
  losses              Int      @default(0)
  matchesPlayed       Int      @default(0)
  matchesScheduled    Int      @default(9)

  // Points calculation
  winPoints           Int      @default(0)
  setPoints           Int      @default(0)
  setsWon             Int      @default(0)
  setsLost            Int      @default(0)

  // Completion bonus
  completionBonus     Int      @default(0)

  // Total
  totalPoints         Int      @default(0)

  // Tie-breaker data
  setDifferential     Int      @default(0)
  headToHead          Json?

  // Tracking
  lastCalculatedAt    DateTime @default(now())
  isLocked            Boolean  @default(false)

  // Relations
  division            Division    @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  season              Season      @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  user                User?       @relation(fields: [userId], references: [id], onDelete: Cascade)
  partnership         Partnership? @relation(fields: [partnershipId], references: [id], onDelete: Cascade)

  @@unique([divisionId, seasonId, userId])
  @@unique([divisionId, seasonId, partnershipId])
  @@index([divisionId, rank])
  @@index([seasonId])
  @@index([totalPoints(sort: Desc)])
  @@map("division_standing")
}

model RatingAdjustment {
  id                String         @id @default(cuid())
  playerRatingId    String
  adminId           String

  // Adjustment details
  adjustmentType    AdjustmentType
  ratingBefore      Int
  ratingAfter       Int
  delta             Int

  // Documentation
  reason            String
  attachmentUrl     String?
  internalNotes     String?

  // Notification tracking
  playerNotified    Boolean        @default(false)
  notifiedAt        DateTime?

  // Audit
  createdAt         DateTime       @default(now())
  ipAddress         String?

  // Relations
  playerRating      PlayerRating   @relation(fields: [playerRatingId], references: [id], onDelete: Cascade)
  admin             Admin          @relation("RatingAdjustments", fields: [adminId], references: [id])

  @@index([playerRatingId, createdAt(sort: Desc)])
  @@index([adminId])
  @@map("rating_adjustment")
}

model RatingParameters {
  id                    String    @id @default(cuid())

  // Scope
  leagueId              String?
  seasonId              String?

  // Core parameters
  initialRating         Int       @default(1500)
  initialRD             Int       @default(350)

  // K-factors
  kFactorNew            Float     @default(40)
  kFactorEstablished    Float     @default(20)
  kFactorThreshold      Int       @default(30)

  // Weightings
  singlesWeight         Float     @default(1.0)
  doublesWeight         Float     @default(1.0)
  oneSetMatchWeight     Float     @default(0.5)

  // Special cases
  walkoverWinImpact     Float     @default(0.5)
  walkoverLossImpact    Float     @default(1.0)

  // Provisional settings
  provisionalThreshold  Int       @default(10)

  // Versioning
  version               Int       @default(1)
  effectiveFrom         DateTime
  effectiveUntil        DateTime?
  isActive              Boolean   @default(true)

  // Audit
  createdByAdminId      String
  createdAt             DateTime  @default(now())
  notes                 String?

  // Relations
  league                League?   @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  season                Season?   @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  createdBy             Admin     @relation("RatingParametersCreated", fields: [createdByAdminId], references: [id])

  @@index([leagueId, isActive])
  @@index([seasonId, isActive])
  @@index([effectiveFrom])
  @@map("rating_parameters")
}

model RatingRecalculation {
  id                    String              @id @default(cuid())

  // Scope
  scope                 RecalculationScope
  matchId               String?
  userId                String?
  divisionId            String?
  seasonId              String?
  leagueId              String?

  // Execution
  status                RecalculationStatus @default(PENDING)
  initiatedByAdminId    String

  // Preview data
  affectedPlayersCount  Int?
  changesPreview        Json?

  // Execution timing
  previewGeneratedAt    DateTime?
  appliedAt             DateTime?
  failedAt              DateTime?
  errorMessage          String?

  // Audit
  createdAt             DateTime            @default(now())

  // Relations
  initiatedBy           Admin               @relation("RatingRecalculations", fields: [initiatedByAdminId], references: [id])

  @@index([status])
  @@index([initiatedByAdminId])
  @@index([createdAt(sort: Desc)])
  @@map("rating_recalculation")
}

model SeasonLock {
  id                String    @id @default(cuid())
  seasonId          String    @unique

  // Lock state
  isLocked          Boolean   @default(true)
  lockedAt          DateTime  @default(now())
  lockedByAdminId   String

  // Export
  finalExportUrl    String?
  exportGeneratedAt DateTime?

  // Override tracking
  overrideAllowed   Boolean   @default(false)
  overrideReason    String?
  overrideByAdminId String?
  overrideAt        DateTime?

  // Relations
  season            Season    @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  lockedBy          Admin     @relation("SeasonLockedBy", fields: [lockedByAdminId], references: [id])
  overrideBy        Admin?    @relation("SeasonOverrideBy", fields: [overrideByAdminId], references: [id])

  @@index([seasonId])
  @@map("season_lock")
}

// =============================================
// END RATING SYSTEM MODELS
// =============================================

// =============================================
// INACTIVITY SYSTEM MODELS
// =============================================

model InactivitySettings {
  id                      String    @id @default(cuid())

  // Scope
  leagueId                String?   @unique
  seasonId                String?   @unique

  // Configuration
  inactivityThresholdDays Int       @default(14)
  warningThresholdDays    Int?

  // Behavior
  autoMarkInactive        Boolean   @default(true)
  excludeFromPairing      Boolean   @default(true)
  sendReminderEmail       Boolean   @default(true)
  reminderDaysBefore      Int?      @default(3)

  // Audit
  updatedByAdminId        String
  updatedAt               DateTime  @updatedAt
  createdAt               DateTime  @default(now())

  // Relations
  league                  League?   @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  season                  Season?   @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  updatedBy               Admin     @relation("InactivitySettingsUpdated", fields: [updatedByAdminId], references: [id])

  @@index([leagueId])
  @@index([seasonId])
  @@map("inactivity_settings")
}

model PlayerStatusChange {
  id              String             @id @default(cuid())
  userId          String

  // Change details
  previousStatus  UserStatus
  newStatus       UserStatus
  reason          StatusChangeReason
  notes           String?

  // Trigger
  triggeredById   String?
  matchId         String?

  createdAt       DateTime           @default(now())

  // Relations
  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  triggeredBy     Admin?             @relation("StatusChangesTriggered", fields: [triggeredById], references: [id])
  match           Match?             @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt(sort: Desc)])
  @@index([newStatus])
  @@index([reason])
  @@map("player_status_change")
}

// =============================================
// END INACTIVITY SYSTEM MODELS
// =============================================

// =============================================
// BUG TRACKING SYSTEM MODELS
// =============================================

model App {
  id              String   @id @default(cuid())
  code            String   @unique
  name            String   @unique
  displayName     String
  description     String?
  appUrl          String?
  logoUrl         String?
  isActive        Boolean  @default(true)

  // Relations
  bugReports      BugReport[]
  bugModules      BugModule[]
  bugSettings     BugReportSettings?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([isActive])
  @@map("app")
}

model BugModule {
  id              String   @id @default(cuid())
  appId           String
  name            String
  code            String
  description     String?
  isActive        Boolean  @default(true)
  sortOrder       Int      @default(0)

  // Relations
  app             App         @relation(fields: [appId], references: [id], onDelete: Cascade)
  bugReports      BugReport[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([appId, code])
  @@index([appId, isActive])
  @@map("bug_module")
}

model BugReport {
  id                  String          @id @default(cuid())
  reportNumber        String          @unique

  // Core fields
  title               String
  description         String
  moduleId            String
  reportType          BugReportType   @default(BUG)
  severity            BugSeverity     @default(MEDIUM)
  stepsToReproduce    String?
  expectedBehavior    String?
  actualBehavior      String?

  // Admin-managed fields
  priority            BugPriority     @default(NORMAL)
  status              BugStatus       @default(NEW)
  assignedToId        String?

  // Auto-captured context
  appId               String
  pageUrl             String?
  userAgent           String?
  browserName         String?
  browserVersion      String?
  osName              String?
  osVersion           String?
  screenWidth         Int?
  screenHeight        Int?
  appVersion          String?
  sessionId           String?
  consoleErrors       Json?
  networkRequests     Json?
  localStorageData    Json?

  // Reporter info
  reporterId          String

  // Resolution
  resolvedById        String?
  resolvedAt          DateTime?
  resolutionNotes     String?
  rootCause           String?
  timeToResolve       Int?

  // Tracking
  viewCount           Int             @default(0)
  duplicateOfId       String?
  externalTicketUrl   String?
  isPublic            Boolean         @default(false)

  // Google Sheets sync
  sheetSyncedAt       DateTime?
  sheetRowId          String?

  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  // Relations
  app                 App             @relation(fields: [appId], references: [id])
  module              BugModule       @relation(fields: [moduleId], references: [id])
  reporter            User            @relation("BugReporter", fields: [reporterId], references: [id])
  assignedTo          Admin?          @relation("BugAssignee", fields: [assignedToId], references: [id])
  resolvedBy          Admin?          @relation("BugResolver", fields: [resolvedById], references: [id])
  duplicateOf         BugReport?      @relation("BugDuplicates", fields: [duplicateOfId], references: [id], onDelete: SetNull)
  duplicates          BugReport[]     @relation("BugDuplicates")
  screenshots         BugScreenshot[]
  comments            BugComment[]
  statusChanges       BugStatusChange[]

  @@index([appId, status])
  @@index([appId, moduleId])
  @@index([reporterId])
  @@index([assignedToId])
  @@index([status, priority])
  @@index([createdAt(sort: Desc)])
  @@index([reportNumber])
  @@map("bug_report")
}

model BugScreenshot {
  id              String   @id @default(cuid())
  bugReportId     String

  // File info
  fileName        String
  fileSize        Int
  mimeType        String
  imageUrl        String
  thumbnailUrl    String?

  // Metadata
  width           Int?
  height          Int?
  caption         String?

  createdAt       DateTime @default(now())

  // Relations
  bugReport       BugReport @relation(fields: [bugReportId], references: [id], onDelete: Cascade)

  @@index([bugReportId])
  @@map("bug_screenshot")
}

model BugComment {
  id              String   @id @default(cuid())
  bugReportId     String
  authorId        String

  content         String
  isInternal      Boolean  @default(false)

  // Reply threading
  parentId        String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  bugReport       BugReport    @relation(fields: [bugReportId], references: [id], onDelete: Cascade)
  author          User         @relation("BugCommentAuthor", fields: [authorId], references: [id])
  parent          BugComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies         BugComment[] @relation("CommentReplies")

  @@index([bugReportId, createdAt])
  @@index([authorId])
  @@map("bug_comment")
}

model BugStatusChange {
  id               String       @id @default(cuid())
  bugReportId      String

  previousStatus   BugStatus?
  newStatus        BugStatus
  previousPriority BugPriority?
  newPriority      BugPriority?
  changedById      String
  notes            String?

  createdAt        DateTime     @default(now())

  // Relations
  bugReport        BugReport    @relation(fields: [bugReportId], references: [id], onDelete: Cascade)
  changedBy        User         @relation("BugStatusChanger", fields: [changedById], references: [id])

  @@index([bugReportId, createdAt(sort: Desc)])
  @@map("bug_status_change")
}

model BugReportSettings {
  id                      String      @id @default(cuid())
  appId                   String      @unique

  // Feature toggles
  enableScreenshots       Boolean     @default(true)
  enableAutoCapture       Boolean     @default(true)
  enableConsoleCapture    Boolean     @default(true)
  enableNetworkCapture    Boolean     @default(false)
  maxScreenshots          Int         @default(5)
  maxFileSize             Int         @default(5242880)

  // Notifications
  notifyEmails            Json?
  slackWebhookUrl         String?
  discordWebhookUrl       String?
  notifyOnNew             Boolean     @default(true)
  notifyOnStatusChange    Boolean     @default(true)

  // Google Sheets integration
  googleSheetId           String?
  googleSheetName         String?
  syncEnabled             Boolean     @default(false)

  // Defaults
  defaultAssigneeId       String?
  defaultPriority         BugPriority @default(NORMAL)

  // Customization
  customFields            Json?

  updatedAt               DateTime    @updatedAt
  createdAt               DateTime    @default(now())

  // Relations
  app                     App         @relation(fields: [appId], references: [id], onDelete: Cascade)
  defaultAssignee         Admin?      @relation("BugDefaultAssignee", fields: [defaultAssigneeId], references: [id])

  @@map("bug_report_settings")
}

// =============================================
// END BUG TRACKING SYSTEM MODELS
// =============================================

model Achievement {
  id               String            @id @default(cuid())
  title            String
  description      String
  icon             String?
  category         String
  requirement      Json?
  points           Int               @default(0)
  isActive         Boolean           @default(true)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  userAchievements UserAchievement[]

  @@index([category])
  @@index([isActive])
}

model UserAchievement {
  id            String      @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime    @default(now())
  progress      Json?
  isCompleted   Boolean     @default(true)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([achievementId])
}

model Thread {
  id        String  @id @default(cuid())
  name      String? // Only for group chats
  avatarUrl String?
  isGroup   Boolean @default(false)

  divisionId String?
  division   Division? @relation("DivisionThreads", fields: [divisionId], references: [id])

  members  UserThread[]
  messages Message[]

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  notifications Notification[]
}

model UserThread {
  id          String   @id @default(cuid())
  thread      Thread   @relation(fields: [threadId], references: [id])
  threadId    String
  user        User     @relation(fields: [userId], references: [id])
  unreadCount Int      @default(0)
  userId      String
  role        String?
  joinedAt    DateTime @default(now())

  @@unique([threadId, userId]) // Prevent duplicate memberships
  @@index([userId])
  @@index([threadId])
}

model Message {
  id       String @id @default(cuid())
  thread   Thread @relation(fields: [threadId], references: [id])
  threadId String
  sender   User   @relation(fields: [senderId], references: [id])
  senderId String

  content String?

  // Reply/Quote/Forwarding
  repliesToId String?
  repliesTo   Message?  @relation("Replies", fields: [repliesToId], references: [id], onDelete: SetNull)
  repliedBy   Message[] @relation("Replies")

  // Message Management
  isEdited  Boolean @default(false)
  isDeleted Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([threadId, createdAt])
}

model Friendship {
  id          String           @id @default(cuid())
  requesterId String
  recipientId String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  respondedAt DateTime?

  requester User @relation("SentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient User @relation("ReceivedFriendRequests", fields: [recipientId], references: [id], onDelete: Cascade)

  @@unique([requesterId, recipientId])
  @@index([requesterId])
  @@index([recipientId])
  @@index([status])
  @@map("friendship")
}

model Favorite {
  id          String   @id @default(cuid())
  userId      String // User who is making the favorite
  favoritedId String // User who is being favorited
  createdAt   DateTime @default(now())

  user      User @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
  favorited User @relation("FavoritedUser", fields: [favoritedId], references: [id], onDelete: Cascade)

  @@unique([userId, favoritedId])
  @@index([userId])
  @@index([favoritedId])
  @@map("favorite")
}

model PairRequest {
  id          String            @id @default(cuid())
  requesterId String
  recipientId String
  seasonId    String
  message     String?
  status      PairRequestStatus
  createdAt   DateTime          @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  requester     User           @relation("SentPairRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient     User           @relation("ReceivedPairRequests", fields: [recipientId], references: [id], onDelete: Cascade)
  season        Season         @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@index([requesterId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@map("pair_request")
}

model Partnership {
  id          String            @id @default(cuid())
  captainId   String // Requester = Captain
  partnerId   String // Recipient = Partner
  seasonId    String
  divisionId  String?
  pairRating  Int?
  status      PartnershipStatus @default(ACTIVE)
  createdAt   DateTime          @default(now())
  dissolvedAt DateTime?

  captain           User                @relation("PartnershipCaptain", fields: [captainId], references: [id], onDelete: Cascade)
  partner           User                @relation("PartnershipPartner", fields: [partnerId], references: [id], onDelete: Cascade)
  season            Season              @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division          Division?           @relation(fields: [divisionId], references: [id], onDelete: SetNull)
  withdrawalRequest WithdrawalRequest[]
  notifications     Notification[]

  // Rating system relations
  divisionStandings DivisionStanding[]

  @@index([seasonId])
  @@index([status])
  @@index([captainId])
  @@index([partnerId])
  @@index([captainId, seasonId, status])
  @@index([partnerId, seasonId, status])
  @@map("partnership")
}

model SeasonInvitation {
  id          String                 @id @default(cuid())
  senderId    String
  recipientId String
  seasonId    String
  message     String?
  status      SeasonInvitationStatus
  createdAt   DateTime               @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  sender    User   @relation("SentSeasonInvitations", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User   @relation("ReceivedSeasonInvitations", fields: [recipientId], references: [id], onDelete: Cascade)
  season    Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  @@unique([senderId, recipientId, seasonId])
  @@index([senderId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@map("season_invitation")
}

model Notification {
  id        String               @id @default(cuid())
  title     String?
  message   String
  category  NotificationCategory
  type      String?
  createdAt DateTime             @default(now())

  seasonId            String?
  divisionId          String?
  matchId             String?
  userId              String?
  partnershipId       String?
  threadId            String?
  pairRequestId       String?
  withdrawalRequestId String?

  // Relations
  season            Season?            @relation(fields: [seasonId], references: [id])
  division          Division?          @relation(fields: [divisionId], references: [id])
  match             Match?             @relation(fields: [matchId], references: [id])
  user              User?              @relation(fields: [userId], references: [id])
  partnership       Partnership?       @relation(fields: [partnershipId], references: [id])
  thread            Thread?            @relation(fields: [threadId], references: [id])
  pairRequest       PairRequest?       @relation(fields: [pairRequestId], references: [id])
  withdrawalRequest WithdrawalRequest? @relation(fields: [withdrawalRequestId], references: [id])

  userNotifications UserNotification[]

  @@index([type])
  @@index([createdAt])
  @@map("notification")
}

model UserNotification {
  id             String    @id @default(cuid())
  userId         String
  notificationId String
  read           Boolean   @default(false)
  archive        Boolean   @default(false)
  readAt         DateTime?

  notification Notification @relation(fields: [notificationId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@unique([userId, notificationId])
  @@index([userId, read])
  @@index([userId, archive])
  @@map("user_notification")
}

enum NotificationCategory {
  DIVISION
  LEAGUE
  CHAT
  MATCH
  SEASON
  PAYMENT
  ADMIN
  GENERAL
}

enum PairRequestStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
  AUTO_DENIED
}

enum PartnershipStatus {
  ACTIVE
  DISSOLVED
  EXPIRED
}

enum Role {
  USER
  ADMIN
  SUPERADMIN
}

enum AdminStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum SeasonStatus {
  UPCOMING
  ACTIVE
  FINISHED
  CANCELLED
}

enum GenderRestriction {
  MALE
  FEMALE
  MIXED
  OPEN
}

enum GenderType {
  MALE
  FEMALE
  MIXED
}

enum MembershipStatus {
  PENDING
  ACTIVE
  FLAGGED
  INACTIVE
  REMOVED
}

enum Statuses {
  ACTIVE
  INACTIVE
  SUSPENDED
  UPCOMING
  ONGOING
  FINISHED
  CANCELLED
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DivisionLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum GameType {
  SINGLES
  DOUBLES
}

enum SportType {
  PADEL
  PICKLEBALL
  TENNIS
}

enum TierType {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

enum SeasonInvitationStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
}

// =============================================
// ADMIN-FOCUSED MATCH MANAGEMENT ENUMS
// =============================================

enum MatchStatus {
  SCHEDULED
  ONGOING
  COMPLETED
  UNFINISHED
  CANCELLED
  VOID
}

enum DisputeCategory {
  WRONG_SCORE
  NO_SHOW
  BEHAVIOR
  OTHER
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  REJECTED
}

enum DisputePriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum DisputeResolutionAction {
  UPHOLD_ORIGINAL
  UPHOLD_DISPUTER
  CUSTOM_SCORE
  VOID_MATCH
  AWARD_WALKOVER
  REQUEST_MORE_INFO
}

enum WalkoverReason {
  NO_SHOW
  LATE_CANCELLATION
  INJURY
  PERSONAL_EMERGENCY
  OTHER
}

enum PenaltyType {
  WARNING
  POINTS_DEDUCTION
  SUSPENSION
  NONE
}

enum PenaltySeverity {
  WARNING
  POINTS_DEDUCTION
  SUSPENSION
  PERMANENT_BAN
}

enum PenaltyStatus {
  ACTIVE
  APPEALED
  OVERTURNED
  EXPIRED
  COMPLETED
}

enum MatchAdminActionType {
  EDIT_RESULT
  VOID_MATCH
  CONVERT_TO_WALKOVER
  OVERRIDE_DISPUTE
  APPLY_PENALTY
  REMOVE_PARTICIPANT
  ADD_PARTICIPANT
  APPROVE_LATE_CANCELLATION
  DENY_LATE_CANCELLATION
  EDIT_SCHEDULE
}

// =============================================
// END ADMIN-FOCUSED MATCH MANAGEMENT ENUMS
// =============================================

// =============================================
// RATING SYSTEM ENUMS
// =============================================

enum RatingChangeReason {
  MATCH_WIN
  MATCH_LOSS
  WALKOVER_WIN
  WALKOVER_LOSS
  MANUAL_ADJUSTMENT
  RECALCULATION
  INITIAL_PLACEMENT
  SEASON_RESET
}

enum AdjustmentType {
  MIGRATION
  CORRECTION
  APPEAL_RESOLUTION
  ADMIN_OVERRIDE
  OTHER
}

enum RecalculationScope {
  MATCH
  PLAYER
  DIVISION
  SEASON
  LEAGUE
}

enum RecalculationStatus {
  PENDING
  GENERATING_PREVIEW
  PREVIEW_READY
  APPLYING
  APPLIED
  FAILED
  CANCELLED
}

// =============================================
// END RATING SYSTEM ENUMS
// =============================================

// =============================================
// INACTIVITY SYSTEM ENUMS
// =============================================

enum StatusChangeReason {
  INACTIVITY_THRESHOLD
  INACTIVITY_WARNING
  MATCH_PLAYED
  ADMIN_MANUAL
  SEASON_START
  SEASON_END
  REGISTRATION
  WITHDRAWAL
}

// =============================================
// END INACTIVITY SYSTEM ENUMS
// =============================================

// =============================================
// BUG TRACKING SYSTEM ENUMS
// =============================================

enum BugReportType {
  BUG
  FEEDBACK
  SUGGESTION
  QUESTION
  IMPROVEMENT
}

enum BugSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum BugPriority {
  URGENT
  HIGH
  NORMAL
  LOW
}

enum BugStatus {
  NEW
  TRIAGED
  IN_PROGRESS
  NEEDS_INFO
  IN_REVIEW
  RESOLVED
  CLOSED
  WONT_FIX
  DUPLICATE
}

// =============================================
// END BUG TRACKING SYSTEM ENUMS
// =============================================
