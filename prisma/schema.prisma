generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String    @id @default(cuid())
  name                String
  email               String    @unique
  emailVerified       Boolean   @default(false)
  image               String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  displayUsername     String?
  username            String    @unique
  role                Role      @default(USER)
  dateOfBirth         DateTime?
  gender              String?
  area                String?
  completedOnboarding Boolean   @default(false)
  lastActivityCheck   DateTime?
  lastLogin           DateTime?
  status              String    @default("active")
  bio                 String?
  phoneNumber         String?
  admin               Admin?

  achievements      UserAchievement[]
  accounts          Account[]
  sessions          Session[]
  seasonMemberships SeasonMembership[]
  matchParticipants MatchParticipant[]
  processedRequests WithdrawalRequest[] @relation("ProcessedByAdmin")

  divisionAssignments DivisionAssignment[] @relation("DivisionAssignments")

  // Pairing & Friendship Relations
  sentFriendRequests        Friendship[]       @relation("SentFriendRequests")
  receivedFriendRequests    Friendship[]       @relation("ReceivedFriendRequests")
  sentPairRequests          PairRequest[]      @relation("SentPairRequests")
  receivedPairRequests      PairRequest[]      @relation("ReceivedPairRequests")
  captainPartnerships       Partnership[]      @relation("PartnershipCaptain")
  partnerPartnerships       Partnership[]      @relation("PartnershipPartner")
  sentSeasonInvitations     SeasonInvitation[] @relation("SentSeasonInvitations")
  receivedSeasonInvitations SeasonInvitation[] @relation("ReceivedSeasonInvitations")

  // Favorite relations
  favoritesMade     Favorite[] @relation("UserFavorites")
  favoritedByOthers Favorite[] @relation("FavoritedUser")

  //Thread relations
  userThreads UserThread[]
  messages    Message[]

  // Questionnaire relations
  questionnaireResponses QuestionnaireResponse[]

  // Notification relations
  notifications     Notification[]
  userNotifications UserNotification[]

  // Admin-focused match management relations
  raisedDisputes     MatchDispute[]   @relation("RaisedDisputes")
  disputeComments    DisputeComment[] @relation("DisputeComments")
  defaultedMatches   MatchWalkover[]  @relation("DefaultedMatches")
  walkoverWins       MatchWalkover[]  @relation("WalkoverWins")
  reportedWalkovers  MatchWalkover[]  @relation("ReportedWalkovers")
  confirmedWalkovers MatchWalkover[]  @relation("ConfirmedWalkovers")
  penalties          PlayerPenalty[]  @relation("UserPenalties")

  @@index([email])
  @@index([username])
  @@index([status])
  @@index([completedOnboarding])
  @@index([createdAt])
  @@map("user")
}

model Admin {
  id        String            @id @default(cuid())
  userId    String?           @unique
  status    AdminStatus       @default(PENDING)
  invitedBy String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  user      User?             @relation(fields: [userId], references: [id])
  invite    AdminInviteToken?

  // Relations
  leagues             League[]
  sponsorships        Sponsorship[]        @relation("SponsorshipCreatedBy")
  divisionsCreated    Division[]           @relation("DivisionCreatedBy")
  divisionsUpdated    Division[]           @relation("DivisionUpdatedBy")
  divisionAssignments DivisionAssignment[] @relation("AssignmentsByAdmin")

  // Admin-focused match management relations
  reviewedDisputes  MatchDispute[]     @relation("ReviewedDisputes")
  resolvedDisputes  MatchDispute[]     @relation("ResolvedDisputes")
  disputeNotes      DisputeAdminNote[] @relation("DisputeNotes")
  verifiedWalkovers MatchWalkover[]    @relation("VerifiedWalkovers")
  issuedPenalties   PlayerPenalty[]    @relation("IssuedPenalties")
  resolvedAppeals   PlayerPenalty[]    @relation("ResolvedAppeals")
  adminMatchActions MatchAdminAction[] @relation("AdminMatchActions")
}

model AdminInviteToken {
  id        String   @id @default(cuid())
  adminId   String   @unique
  email     String
  token     String   @unique
  status    String   @default("PENDING")
  createdAt DateTime @default(now())
  expiresAt DateTime
  admin     Admin    @relation(fields: [adminId], references: [id])
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("account")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("session")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String   @unique
  status     String   @default("PENDING")
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

model QuestionnaireResponse {
  id          Int                  @id @default(autoincrement())
  userId      String
  sport       String
  qVersion    Int
  qHash       String
  answersJson Json
  startedAt   DateTime             @default(now())
  completedAt DateTime?
  result      InitialRatingResult?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sport, qVersion])
  @@index([qHash])
}

model InitialRatingResult {
  id         Int                   @id @default(autoincrement())
  responseId Int                   @unique
  source     String
  singles    Int?
  doubles    Int?
  rd         Int?
  confidence String?
  detail     Json?
  createdAt  DateTime              @default(now())
  response   QuestionnaireResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)
}

model League {
  id          String  @id @default(cuid())
  name        String  @db.VarChar(255)
  location    String?
  description String?

  status    Statuses  @default(UPCOMING)
  sportType SportType
  gameType  GameType

  createdById String?
  createdBy   Admin?  @relation(fields: [createdById], references: [id])

  seasons      Season[]      @relation("LeagueToSeason")
  sponsorships Sponsorship[]
  divisions    Division[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([location])
  @@index([status])
}

model Category {
  id   String  @id @default(cuid())
  name String? @db.VarChar(255)

  // Restrictions and Format
  genderRestriction GenderRestriction @default(OPEN)
  matchFormat       String? // 'match_format' e.g., Best of 3 sets
  game_type         GameType?
  gender_category   GenderType?
  isActive          Boolean           @default(true)
  categoryOrder     Int               @default(0)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  seasons Season[]

  @@index([isActive])
}

// Not using now 
// model Company {
// id           String   @id @default(cuid())
// name         String   @db.VarChar(255)
// contactEmail String?  @unique
// website      String?
// logoUrl      String?
// createdAt    DateTime @default(now())
// updatedAt    DateTime @updatedAt

//  createdById      String? 
//  createdBy        Admin?        @relation(fields: [createdById], references: [id])
//  sponsorshipDeals Sponsorship[]
//
//  @@map("company")
//}

model Sponsorship {
  id             String   @id @default(cuid())
  packageTier    TierType
  contractAmount Decimal? @db.Decimal(10, 2)
  sponsorRevenue Decimal? @db.Decimal(10, 2)
  sponsoredName  String?
  createdById    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships
  leagues   League[]
  createdBy Admin?     @relation("SponsorshipCreatedBy", fields: [createdById], references: [id])
  divisions Division[] @relation("DivisionSponsor")
  seasons   Season[]   @relation("SeasonSponsor")

  @@map("sponsorship")
}

model Season {
  id                  String    @id @default(cuid())
  name                String
  startDate           DateTime?
  endDate             DateTime?
  regiDeadline        DateTime?
  entryFee            Decimal   @db.Decimal(10, 2)
  description         String?
  registeredUserCount Int       @default(0)

  //Bools
  status             SeasonStatus @default(UPCOMING)
  isActive           Boolean      @default(false)
  paymentRequired    Boolean      @default(false)
  promoCodeSupported Boolean      @default(false)
  withdrawalEnabled  Boolean      @default(false)

  //Relations
  divisions          Division[]
  memberships        SeasonMembership[]
  promoCodes         PromoCode[]         @relation("SeasonPromoCodes")
  withdrawalRequests WithdrawalRequest[]

  // Pairing Relations
  pairRequests      PairRequest[]
  partnerships      Partnership[]
  seasonInvitations SeasonInvitation[]

  leagues League[] @relation("LeagueToSeason")

  categoryId String?
  category   Category?    @relation(fields: [categoryId], references: [id])
  sponsorId  String?
  sponsor    Sponsorship? @relation("SeasonSponsor", fields: [sponsorId], references: [id], onDelete: SetNull)

  notifications Notification[]

  waitlistId String?
  waitlist   Waitlist? @relation

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([isActive])
  @@index([sponsorId])
}

model Waitlist {
  id              String         @id @default(cuid())
  seasonId        String         @unique
  season          Season         @relation(fields: [seasonId], references: [id])
  enabled         Boolean        @default(false)
  maxParticipants Int?
  waitlistedUsers WaitlistUser[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WaitlistUser {
  id                   String   @id @default(cuid())
  waitlistId           String
  userId               String
  waitlistDate         DateTime @default(now())
  promotedToRegistered Boolean  @default(false)

  waitlist Waitlist @relation(fields: [waitlistId], references: [id])

  @@unique([waitlistId, userId])
  @@index([userId])
}

model PromoCode {
  id            String    @id @default(cuid())
  code          String    @unique
  description   String?
  discountValue Decimal   @db.Decimal(10, 2)
  isPercentage  Boolean   @default(false) // True for %, false for fixed amount
  isActive      Boolean   @default(true)
  expiresAt     DateTime?

  seasons Season[] @relation("SeasonPromoCodes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WithdrawalRequest {
  id                 String           @id @default(cuid())
  userId             String
  reason             String
  requestDate        DateTime         @default(now())
  status             WithdrawalStatus @default(PENDING)
  processedByAdminId String?
  partnershipId      String? // For partner change requests

  processedByAdmin User?          @relation("ProcessedByAdmin", fields: [processedByAdminId], references: [id])
  seasonId         String
  season           Season         @relation(fields: [seasonId], references: [id])
  partnership      Partnership?   @relation(fields: [partnershipId], references: [id])
  notifications    Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Division {
  id             String         @id @default(cuid())
  name           String
  description    String?
  level          DivisionLevel?
  gameType       GameType
  genderCategory GenderType?

  // capacities
  maxSinglesPlayers Int?
  maxDoublesTeams   Int?

  // denormalized counts
  currentSinglesCount Int? @default(0)
  currentDoublesCount Int? @default(0)

  autoAssignmentEnabled Boolean @default(false)
  isActiveDivision      Boolean @default(true)
  pointsThreshold       Int?

  // Sponsorship fields
  divisionSponsorId     String? // division_sponsor_id
  divisionSponsor       Sponsorship? @relation("DivisionSponsor", fields: [divisionSponsorId], references: [id], onDelete: SetNull)
  sponsoredDivisionName String? // sponsored_division_name
  prizePoolTotal        Decimal?     @db.Decimal(10, 2) // prize_pool_total

  // audit â€” Admin FKs
  createdByAdminId     String?
  createdByAdmin       Admin?  @relation("DivisionCreatedBy", fields: [createdByAdminId], references: [id], onDelete: SetNull)
  lastUpdatedByAdminId String?
  lastUpdatedByAdmin   Admin?  @relation("DivisionUpdatedBy", fields: [lastUpdatedByAdminId], references: [id], onDelete: SetNull)

  // Relations
  matches           Match[]
  assignments       DivisionAssignment[] // Player assignments tracking
  seasonMemberships SeasonMembership[]   @relation("SeasonMembershipDivision")
  seasonId          String
  season            Season               @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  leagueId          String
  league            League               @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  threads           Thread[]             @relation("DivisionThreads")
  notifications     Notification[]

  // Pairing Relations
  partnerships Partnership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([seasonId, name])
  @@index([seasonId])
  @@index([leagueId])
  @@index([isActiveDivision])
  @@index([divisionSponsorId])
  @@map("division")
}

model SeasonMembership {
  id               String        @id @default(cuid())
  userId           String
  seasonId         String
  divisionId       String?
  status           String        @default("PENDING") // 'PENDING' | 'ACTIVE' | 'INACTIVE' | 'FLAGGED' | 'REMOVED'
  joinedAt         DateTime      @default(now())
  withdrawalReason String? // For handling "View Withdrawal Request"
  paymentStatus    PaymentStatus @default(PENDING)

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  season   Season    @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division Division? @relation("SeasonMembershipDivision", fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([userId, seasonId, divisionId])
  @@index([userId])
  @@index([seasonId])
  @@index([divisionId, status])
}

model DivisionAssignment {
  id                String   @id @default(cuid())
  divisionId        String
  userId            String
  assignedBy        String? // Admin ID who made the assignment
  assignedAt        DateTime @default(now())
  reassignmentCount Int      @default(0) // Track how many times player was moved
  notes             String? // Admin notes for assignment

  // Relations
  division        Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  user            User     @relation("DivisionAssignments", fields: [userId], references: [id], onDelete: Cascade)
  assignedByAdmin Admin?   @relation("AssignmentsByAdmin", fields: [assignedBy], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([divisionId, userId])
  @@index([divisionId])
  @@index([userId])
  @@index([assignedBy])
  @@map("division_assignment")
}

model Match {
  id            String   @id @default(cuid())
  divisionId    String?
  leagueId      String?
  seasonId      String?
  sport         String
  matchType     String
  playerScore   Int?
  opponentScore Int?
  outcome       String?
  matchDate     DateTime @default(now())
  location      String?
  notes         String?
  duration      Int?

  // Enhanced fields for admin management
  status         MatchStatus @default(SCHEDULED)
  isWalkover     Boolean     @default(false)
  walkoverReason String?
  isDisputed     Boolean     @default(false)
  adminNotes     String?

  division      Division?          @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  participants  MatchParticipant[]
  stats         MatchStats?
  notifications Notification[]

  // Admin-focused relations
  disputes     MatchDispute[]
  walkover     MatchWalkover?
  adminActions MatchAdminAction[]
  penalties    PlayerPenalty[]    @relation("MatchPenalties")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([divisionId])
  @@index([leagueId])
  @@index([seasonId])
  @@index([sport])
  @@index([matchDate])
  @@index([status])
  @@index([isDisputed])
  @@index([matchType])
}

//TO DO - use this and link with seasonmembership
model MatchParticipant {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  isStarter Boolean  @default(true)
  team      String?
  createdAt DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@index([userId])
  @@index([matchId])
}

model MatchStats {
  id                     String   @id @default(cuid())
  matchId                String   @unique
  playerAces             Int?
  playerUnforcedErrors   Int?
  playerWinners          Int?
  playerDoubleFaults     Int?
  opponentAces           Int?
  opponentUnforcedErrors Int?
  opponentWinners        Int?
  opponentDoubleFaults   Int?
  rallyCount             Int?
  longestRally           Int?
  breakPointsConverted   Int?
  breakPointsTotal       Int?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  match                  Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
}

// =============================================
// ADMIN-FOCUSED MATCH MANAGEMENT MODELS
// =============================================

model MatchDispute {
  id              String          @id @default(cuid())
  matchId         String          @unique
  raisedByUserId  String
  disputeCategory DisputeCategory
  disputeComment  String
  disputerScore   Json?
  evidenceUrl     String?
  submittedAt     DateTime        @default(now())

  // Admin resolution fields
  adminResolution   String?
  resolutionAction  DisputeResolutionAction?
  finalScore        Json?
  resolvedAt        DateTime?
  status            DisputeStatus            @default(OPEN)
  priority          DisputePriority          @default(NORMAL)
  flaggedForReview  Boolean                  @default(false)
  reviewedByAdminId String?
  resolvedByAdminId String?

  // Relations
  match           Match              @relation(fields: [matchId], references: [id], onDelete: Cascade)
  raisedByUser    User               @relation("RaisedDisputes", fields: [raisedByUserId], references: [id])
  reviewedByAdmin Admin?             @relation("ReviewedDisputes", fields: [reviewedByAdminId], references: [id])
  resolvedByAdmin Admin?             @relation("ResolvedDisputes", fields: [resolvedByAdminId], references: [id])
  adminNotes      DisputeAdminNote[]
  comments        DisputeComment[]

  @@index([matchId])
  @@index([raisedByUserId])
  @@index([status])
  @@index([priority])
  @@index([reviewedByAdminId])
  @@map("match_dispute")
}

model DisputeAdminNote {
  id             String   @id @default(cuid())
  disputeId      String
  adminId        String
  note           String
  isInternalOnly Boolean  @default(true)
  createdAt      DateTime @default(now())

  dispute MatchDispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  admin   Admin        @relation("DisputeNotes", fields: [adminId], references: [id])

  @@index([disputeId, createdAt(sort: Desc)])
  @@map("dispute_admin_note")
}

model DisputeComment {
  id          String   @id @default(cuid())
  disputeId   String
  senderId    String
  comment     String
  attachments Json?
  createdAt   DateTime @default(now())

  dispute MatchDispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender  User         @relation("DisputeComments", fields: [senderId], references: [id])

  @@index([disputeId, createdAt(sort: Asc)])
  @@map("dispute_comment")
}

model MatchWalkover {
  id                   String         @id @default(cuid())
  matchId              String         @unique
  walkoverFlag         Boolean        @default(true)
  walkoverReason       WalkoverReason
  walkoverReasonDetail String?
  defaultingPlayerId   String
  winningPlayerId      String
  reportedBy           String
  confirmedBy          String?
  adminVerified        Boolean        @default(false)
  adminVerifiedBy      String?
  adminVerifiedAt      DateTime?
  penaltyApplied       Boolean        @default(false)
  penaltyType          PenaltyType?
  penaltyDetails       String?
  penaltyId            String?
  createdAt            DateTime       @default(now())

  match            Match          @relation(fields: [matchId], references: [id], onDelete: Cascade)
  defaultingPlayer User           @relation("DefaultedMatches", fields: [defaultingPlayerId], references: [id])
  winningPlayer    User           @relation("WalkoverWins", fields: [winningPlayerId], references: [id])
  reporter         User           @relation("ReportedWalkovers", fields: [reportedBy], references: [id])
  confirmer        User?          @relation("ConfirmedWalkovers", fields: [confirmedBy], references: [id])
  verifiedByAdmin  Admin?         @relation("VerifiedWalkovers", fields: [adminVerifiedBy], references: [id])
  penalty          PlayerPenalty? @relation(fields: [penaltyId], references: [id])

  @@index([matchId])
  @@index([defaultingPlayerId])
  @@index([adminVerified])
  @@map("match_walkover")
}

model PlayerPenalty {
  id                    String          @id @default(cuid())
  userId                String
  penaltyType           PenaltyType
  severity              PenaltySeverity
  relatedMatchId        String?
  relatedDisputeId      String?
  pointsDeducted        Int?
  suspensionDays        Int?
  suspensionStartDate   DateTime?
  suspensionEndDate     DateTime?
  issuedByAdminId       String
  reason                String
  evidenceUrl           String?
  status                PenaltyStatus   @default(ACTIVE)
  appealSubmittedAt     DateTime?
  appealReason          String?
  appealResolvedBy      String?
  appealResolvedAt      DateTime?
  appealResolutionNotes String?
  expiresAt             DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  user                  User            @relation("UserPenalties", fields: [userId], references: [id])
  relatedMatch          Match?          @relation("MatchPenalties", fields: [relatedMatchId], references: [id])
  issuedByAdmin         Admin           @relation("IssuedPenalties", fields: [issuedByAdminId], references: [id])
  appealResolvedByAdmin Admin?          @relation("ResolvedAppeals", fields: [appealResolvedBy], references: [id])
  walkovers             MatchWalkover[]

  @@index([userId, status])
  @@index([penaltyType])
  @@index([status])
  @@index([issuedByAdminId])
  @@index([expiresAt])
  @@map("player_penalty")
}

model MatchAdminAction {
  id                     String               @id @default(cuid())
  matchId                String
  adminId                String
  actionType             MatchAdminActionType
  oldValue               Json?
  newValue               Json?
  reason                 String
  affectedUserIds        Json?
  triggeredRecalculation Boolean              @default(false)
  recalculationDetails   Json?
  notifiedUsers          Json?
  ipAddress              String?
  createdAt              DateTime             @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  admin Admin @relation("AdminMatchActions", fields: [adminId], references: [id])

  @@index([matchId, createdAt(sort: Desc)])
  @@index([adminId, createdAt(sort: Desc)])
  @@index([actionType])
  @@map("match_admin_action")
}

// =============================================
// END ADMIN-FOCUSED MATCH MANAGEMENT MODELS
// =============================================

model Achievement {
  id               String            @id @default(cuid())
  title            String
  description      String
  icon             String?
  category         String
  requirement      Json?
  points           Int               @default(0)
  isActive         Boolean           @default(true)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  userAchievements UserAchievement[]

  @@index([category])
  @@index([isActive])
}

model UserAchievement {
  id            String      @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime    @default(now())
  progress      Json?
  isCompleted   Boolean     @default(true)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([achievementId])
}

model Thread {
  id        String  @id @default(cuid())
  name      String? // Only for group chats
  avatarUrl String?
  isGroup   Boolean @default(false)

  divisionId String?
  division   Division? @relation("DivisionThreads", fields: [divisionId], references: [id])

  members  UserThread[]
  messages Message[]

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  notifications Notification[]
}

model UserThread {
  id          String   @id @default(cuid())
  thread      Thread   @relation(fields: [threadId], references: [id])
  threadId    String
  user        User     @relation(fields: [userId], references: [id])
  unreadCount Int      @default(0)
  userId      String
  role        String?
  joinedAt    DateTime @default(now())

  @@unique([threadId, userId]) // Prevent duplicate memberships
}

model Message {
  id       String @id @default(cuid())
  thread   Thread @relation(fields: [threadId], references: [id])
  threadId String
  sender   User   @relation(fields: [senderId], references: [id])
  senderId String

  content String?

  // Reply/Quote/Forwarding
  repliesToId String?
  repliesTo   Message?  @relation("Replies", fields: [repliesToId], references: [id], onDelete: SetNull)
  repliedBy   Message[] @relation("Replies")

  // Message Management
  isEdited  Boolean @default(false)
  isDeleted Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([threadId, createdAt])
}

model Friendship {
  id          String           @id @default(cuid())
  requesterId String
  recipientId String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  respondedAt DateTime?

  requester User @relation("SentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient User @relation("ReceivedFriendRequests", fields: [recipientId], references: [id], onDelete: Cascade)

  @@unique([requesterId, recipientId])
  @@index([requesterId])
  @@index([recipientId])
  @@index([status])
  @@map("friendship")
}

model Favorite {
  id          String   @id @default(cuid())
  userId      String // User who is making the favorite
  favoritedId String // User who is being favorited
  createdAt   DateTime @default(now())

  user      User @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
  favorited User @relation("FavoritedUser", fields: [favoritedId], references: [id], onDelete: Cascade)

  @@unique([userId, favoritedId])
  @@index([userId])
  @@index([favoritedId])
  @@map("favorite")
}

model PairRequest {
  id          String            @id @default(cuid())
  requesterId String
  recipientId String
  seasonId    String
  message     String?
  status      PairRequestStatus
  createdAt   DateTime          @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  requester     User           @relation("SentPairRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient     User           @relation("ReceivedPairRequests", fields: [recipientId], references: [id], onDelete: Cascade)
  season        Season         @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@index([requesterId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@map("pair_request")
}

model Partnership {
  id          String            @id @default(cuid())
  captainId   String // Requester = Captain
  partnerId   String // Recipient = Partner
  seasonId    String
  divisionId  String?
  pairRating  Int?
  status      PartnershipStatus @default(ACTIVE)
  createdAt   DateTime          @default(now())
  dissolvedAt DateTime?

  captain           User                @relation("PartnershipCaptain", fields: [captainId], references: [id], onDelete: Cascade)
  partner           User                @relation("PartnershipPartner", fields: [partnerId], references: [id], onDelete: Cascade)
  season            Season              @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division          Division?           @relation(fields: [divisionId], references: [id], onDelete: SetNull)
  withdrawalRequest WithdrawalRequest[]
  notifications     Notification[]

  @@index([seasonId])
  @@index([status])
  @@index([captainId])
  @@index([partnerId])
  @@index([captainId, seasonId, status])
  @@index([partnerId, seasonId, status])
  @@map("partnership")
}

model SeasonInvitation {
  id          String                 @id @default(cuid())
  senderId    String
  recipientId String
  seasonId    String
  message     String?
  status      SeasonInvitationStatus
  createdAt   DateTime               @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  sender    User   @relation("SentSeasonInvitations", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User   @relation("ReceivedSeasonInvitations", fields: [recipientId], references: [id], onDelete: Cascade)
  season    Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  @@unique([senderId, recipientId, seasonId])
  @@index([senderId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@map("season_invitation")
}

model Notification {
  id        String               @id @unique @default(cuid())
  title     String?
  message   String
  category  NotificationCategory
  type      String?
  createdAt DateTime             @default(now())

  seasonId            String?
  divisionId          String?
  matchId             String?
  userId              String?
  partnershipId       String?
  threadId            String?
  pairRequestId       String?
  withdrawalRequestId String?

  // Relations
  season            Season?            @relation(fields: [seasonId], references: [id])
  division          Division?          @relation(fields: [divisionId], references: [id])
  match             Match?             @relation(fields: [matchId], references: [id])
  user              User?              @relation(fields: [userId], references: [id])
  partnership       Partnership?       @relation(fields: [partnershipId], references: [id])
  thread            Thread?            @relation(fields: [threadId], references: [id])
  pairRequest       PairRequest?       @relation(fields: [pairRequestId], references: [id])
  withdrawalRequest WithdrawalRequest? @relation(fields: [withdrawalRequestId], references: [id])

  userNotifications UserNotification[]

  @@index([type])
  @@index([createdAt])
  @@map("notification")
}

model UserNotification {
  id             String    @id @unique @default(cuid())
  userId         String
  notificationId String
  read           Boolean   @default(false)
  archive        Boolean   @default(false)
  readAt         DateTime?

  notification Notification @relation(fields: [notificationId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@unique([userId, notificationId])
  @@index([userId, read])
  @@index([userId, archive])
  @@map("user_notification")
}

enum NotificationCategory {
  DIVISION
  LEAGUE
  CHAT
  MATCH
  SEASON
  PAYMENT
  ADMIN
  GENERAL
}

enum PairRequestStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
  AUTO_DENIED
}

enum PartnershipStatus {
  ACTIVE
  DISSOLVED
  EXPIRED
}

enum Role {
  USER
  ADMIN
  SUPERADMIN
}

enum AdminStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum SeasonStatus {
  UPCOMING
  ACTIVE
  FINISHED
  CANCELLED
}

enum GenderRestriction {
  MALE
  FEMALE
  MIXED
  OPEN
}

enum GenderType {
  MALE
  FEMALE
  MIXED
}

enum MembershipStatus {
  PENDING
  ACTIVE
  FLAGGED
  INACTIVE
  REMOVED
}

enum Statuses {
  ACTIVE
  INACTIVE
  SUSPENDED
  UPCOMING
  ONGOING
  FINISHED
  CANCELLED
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DivisionLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum GameType {
  SINGLES
  DOUBLES
}

enum SportType {
  PADEL
  PICKLEBALL
  TENNIS
}

enum TierType {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

enum SeasonInvitationStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
}

// =============================================
// ADMIN-FOCUSED MATCH MANAGEMENT ENUMS
// =============================================

enum MatchStatus {
  SCHEDULED
  ONGOING
  COMPLETED
  UNFINISHED
  CANCELLED
  VOID
}

enum DisputeCategory {
  WRONG_SCORE
  NO_SHOW
  BEHAVIOR
  OTHER
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  REJECTED
}

enum DisputePriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum DisputeResolutionAction {
  UPHOLD_ORIGINAL
  UPHOLD_DISPUTER
  CUSTOM_SCORE
  VOID_MATCH
  AWARD_WALKOVER
  REQUEST_MORE_INFO
}

enum WalkoverReason {
  NO_SHOW
  LATE_CANCELLATION
  INJURY
  PERSONAL_EMERGENCY
  OTHER
}

enum PenaltyType {
  WARNING
  POINTS_DEDUCTION
  SUSPENSION
  NONE
}

enum PenaltySeverity {
  WARNING
  POINTS_DEDUCTION
  SUSPENSION
  PERMANENT_BAN
}

enum PenaltyStatus {
  ACTIVE
  APPEALED
  OVERTURNED
  EXPIRED
  COMPLETED
}

enum MatchAdminActionType {
  EDIT_RESULT
  VOID_MATCH
  CONVERT_TO_WALKOVER
  OVERRIDE_DISPUTE
  APPLY_PENALTY
  REMOVE_PARTICIPANT
  ADD_PARTICIPANT
  APPROVE_LATE_CANCELLATION
  DENY_LATE_CANCELLATION
  EDIT_SCHEDULE
}

// =============================================
// END ADMIN-FOCUSED MATCH MANAGEMENT ENUMS
// =============================================
