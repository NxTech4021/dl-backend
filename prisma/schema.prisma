generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String    @id @default(cuid())
  name                String
  email               String    @unique
  emailVerified       Boolean   @default(false)
  image               String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  displayUsername     String?
  username            String    @unique
  role                Role      @default(USER)
  dateOfBirth         DateTime?
  gender              String?
  area                String?
  completedOnboarding Boolean   @default(false)
  lastActivityCheck   DateTime?
  lastLogin           DateTime?
  status              String    @default("active")
  bio                 String?
  phoneNumber         String?
  admin               Admin?

  achievements      UserAchievement[]
  accounts          Account[]
  sessions          Session[]
  seasonMemberships SeasonMembership[]
  matchParticipants MatchParticipant[]
  processedRequests WithdrawalRequest[] @relation("ProcessedByAdmin")

  divisionAssignments DivisionAssignment[] @relation("DivisionAssignments")

  // Pairing & Friendship Relations
  sentFriendRequests        Friendship[]       @relation("SentFriendRequests")
  receivedFriendRequests    Friendship[]       @relation("ReceivedFriendRequests")
  sentPairRequests          PairRequest[]      @relation("SentPairRequests")
  receivedPairRequests      PairRequest[]      @relation("ReceivedPairRequests")
  captainPartnerships       Partnership[]      @relation("PartnershipCaptain")
  partnerPartnerships       Partnership[]      @relation("PartnershipPartner")
  sentSeasonInvitations     SeasonInvitation[] @relation("SentSeasonInvitations")
  receivedSeasonInvitations SeasonInvitation[] @relation("ReceivedSeasonInvitations")

  // Favorite relations
  favoritesMade     Favorite[] @relation("UserFavorites")
  favoritedByOthers Favorite[] @relation("FavoritedUser")

  //Thread relations
  userThreads  UserThread[]
  messages     Message[]
  readMessages MessageReadBy[]

  // Questionnaire relations
  questionnaireResponses QuestionnaireResponse[]

  // Notification relations
  notifications     Notification[]
  userNotifications UserNotification[]

  @@index([email])
  @@index([username])
  @@index([status])
  @@index([completedOnboarding])
  @@index([createdAt])
  @@map("user")
}

model Admin {
  id        String            @id @default(cuid())
  userId    String?           @unique
  status    AdminStatus       @default(PENDING)
  invitedBy String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  user      User?             @relation(fields: [userId], references: [id])
  invite    AdminInviteToken?

  // Relations
  leagues             League[]
  sponsorships        Sponsorship[]        @relation("SponsorshipCreatedBy")
  divisionsCreated    Division[]           @relation("DivisionCreatedBy")
  divisionsUpdated    Division[]           @relation("DivisionUpdatedBy")
  divisionAssignments DivisionAssignment[] @relation("AssignmentsByAdmin")
}

model AdminInviteToken {
  id        String   @id @default(cuid())
  adminId   String   @unique
  email     String
  token     String   @unique
  status    String   @default("PENDING")
  createdAt DateTime @default(now())
  expiresAt DateTime
  admin     Admin    @relation(fields: [adminId], references: [id])
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("account")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("session")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String   @unique
  status     String   @default("PENDING")
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

model QuestionnaireResponse {
  id          Int                  @id @default(autoincrement())
  userId      String
  sport       String
  qVersion    Int
  qHash       String
  answersJson Json
  startedAt   DateTime             @default(now())
  completedAt DateTime?
  result      InitialRatingResult?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sport, qVersion])
  @@index([qHash])
}

model InitialRatingResult {
  id         Int                   @id @default(autoincrement())
  responseId Int                   @unique
  source     String
  singles    Int?
  doubles    Int?
  rd         Int?
  confidence String?
  detail     Json?
  createdAt  DateTime              @default(now())
  response   QuestionnaireResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)
}

model League {
  id          String  @id @default(cuid())
  name        String  @db.VarChar(255)
  location    String?
  description String?

  status    Statuses  @default(UPCOMING)
  sportType SportType
  gameType  GameType

  createdById String?
  createdBy   Admin?  @relation(fields: [createdById], references: [id])

  seasons      Season[]           @relation("LeagueToSeason")
  sponsorships Sponsorship[]
  categories   Category[]
  divisions    Division[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([location])
  @@index([status])
}

model Category {
  id   String  @id @default(cuid())
  name String? @db.VarChar(255)

  // Restrictions and Format
  genderRestriction GenderRestriction @default(OPEN) // 'gender_restriction' enum
  matchFormat       String? // 'match_format' e.g., Best of 3 sets
  game_type         GameType?
  gender_category   GenderType?
  isActive          Boolean           @default(true) // 'is_active'
  categoryOrder     Int               @default(0) // 'category_order' for display
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  leagues           League[]
  seasons           Season[]

  @@index([isActive])
}

// Not using now 
// model Company {
// id           String   @id @default(cuid())
// name         String   @db.VarChar(255)
// contactEmail String?  @unique
// website      String?
// logoUrl      String?
// createdAt    DateTime @default(now())
// updatedAt    DateTime @updatedAt

//  createdById      String? 
//  createdBy        Admin?        @relation(fields: [createdById], references: [id])
//  sponsorshipDeals Sponsorship[]
//
//  @@map("company")
//}

model Sponsorship {
  id             String   @id @default(cuid())
  packageTier    TierType
  contractAmount Decimal? @db.Decimal(10, 2)
  sponsorRevenue Decimal? @db.Decimal(10, 2)
  sponsoredName  String?
  createdById    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships
  leagues   League[]
  createdBy Admin?     @relation("SponsorshipCreatedBy", fields: [createdById], references: [id])
  divisions Division[] @relation("DivisionSponsor")

  @@map("sponsorship")
}

model Season {
  id                  String    @id @default(cuid())
  name                String
  startDate           DateTime?
  endDate             DateTime?
  regiDeadline        DateTime?
  entryFee            Decimal   @db.Decimal(10, 2)
  description         String?
  registeredUserCount Int       @default(0)

  //Bools
  status             SeasonStatus @default(UPCOMING)
  isActive           Boolean      @default(false)
  paymentRequired    Boolean      @default(false)
  promoCodeSupported Boolean      @default(false)
  withdrawalEnabled  Boolean      @default(false)

  //Relations
  divisions          Division[]
  memberships        SeasonMembership[]
  promoCodes         PromoCode[]         @relation("SeasonPromoCodes")
  withdrawalRequests WithdrawalRequest[]

  // Pairing Relations
  pairRequests      PairRequest[]
  partnerships      Partnership[]
  seasonInvitations SeasonInvitation[]

  leagues    League[]   @relation("LeagueToSeason")
  categories Category[]
  notifications Notification[]

  waitlistId String?
  waitlist   Waitlist? @relation

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([isActive])
}

model Waitlist {
  id              String         @id @default(cuid())
  seasonId        String         @unique
  season          Season         @relation(fields: [seasonId], references: [id])
  enabled         Boolean        @default(false)
  maxParticipants Int?
  waitlistedUsers WaitlistUser[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WaitlistUser {
  id                   String   @id @default(cuid())
  waitlistId           String
  userId               String
  waitlistDate         DateTime @default(now())
  promotedToRegistered Boolean  @default(false)

  waitlist Waitlist @relation(fields: [waitlistId], references: [id])

  @@unique([waitlistId, userId])
  @@index([userId])
}

model PromoCode {
  id            String    @id @default(cuid())
  code          String    @unique
  description   String?
  discountValue Decimal   @db.Decimal(10, 2)
  isPercentage  Boolean   @default(false) // True for %, false for fixed amount
  isActive      Boolean   @default(true)
  expiresAt     DateTime?

  seasons Season[] @relation("SeasonPromoCodes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WithdrawalRequest {
  id                 String           @id @default(cuid())
  userId             String
  reason             String
  requestDate        DateTime         @default(now())
  status             WithdrawalStatus @default(PENDING)
  processedByAdminId String?
  partnershipId      String? // For partner change requests

  processedByAdmin User?        @relation("ProcessedByAdmin", fields: [processedByAdminId], references: [id])
  seasonId         String
  season           Season       @relation(fields: [seasonId], references: [id])
  partnership      Partnership? @relation(fields: [partnershipId], references: [id])
  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Division {
  id             String         @id @default(cuid())
  name           String
  description    String?
  level          DivisionLevel?
  gameType       GameType
  genderCategory GenderType?

  // capacities
  maxSinglesPlayers Int?
  maxDoublesTeams   Int?

  // denormalized counts
  currentSinglesCount Int? @default(0)
  currentDoublesCount Int? @default(0)

  autoAssignmentEnabled Boolean @default(false)
  isActiveDivision      Boolean @default(true)
  pointsThreshold       Int?

  // Sponsorship fields (from Excel spec)
  divisionSponsorId     String? // division_sponsor_id
  divisionSponsor       Sponsorship? @relation("DivisionSponsor", fields: [divisionSponsorId], references: [id], onDelete: SetNull)
  sponsoredDivisionName String? // sponsored_division_name
  prizePoolTotal        Decimal?     @db.Decimal(10, 2) // prize_pool_total

  // audit â€” Admin FKs
  createdByAdminId     String?
  createdByAdmin       Admin?  @relation("DivisionCreatedBy", fields: [createdByAdminId], references: [id], onDelete: SetNull)
  lastUpdatedByAdminId String?
  lastUpdatedByAdmin   Admin?  @relation("DivisionUpdatedBy", fields: [lastUpdatedByAdminId], references: [id], onDelete: SetNull)

  // Relations
  matches           Match[]
  assignments       DivisionAssignment[] // Player assignments tracking
  seasonMemberships SeasonMembership[]   @relation("SeasonMembershipDivision")
  seasonId          String
  season            Season               @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  leagueId          String
  league            League               @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  threads           Thread[]             @relation("DivisionThreads")
  notifications Notification[]

  // Pairing Relations
  partnerships Partnership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([seasonId, name])
  @@index([seasonId])
  @@index([leagueId])
  @@index([isActiveDivision])
  @@index([divisionSponsorId])
  @@map("division")
}

model SeasonMembership {
  id               String        @id @default(cuid())
  userId           String
  seasonId         String
  divisionId       String?
  status           String        @default("PENDING") // 'PENDING' | 'ACTIVE' | 'INACTIVE' | 'FLAGGED' | 'REMOVED'
  joinedAt         DateTime      @default(now())
  withdrawalReason String? // For handling "View Withdrawal Request"
  paymentStatus    PaymentStatus @default(PENDING)

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  season   Season    @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division Division? @relation("SeasonMembershipDivision", fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([userId, seasonId, divisionId])
  @@index([userId])
  @@index([seasonId])
  @@index([divisionId, status])
}

model DivisionAssignment {
  id                String   @id @default(cuid())
  divisionId        String
  userId            String
  assignedBy        String? // Admin ID who made the assignment
  assignedAt        DateTime @default(now())
  reassignmentCount Int      @default(0) // Track how many times player was moved
  notes             String? // Admin notes for assignment

  // Relations
  division        Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  user            User     @relation("DivisionAssignments", fields: [userId], references: [id], onDelete: Cascade)
  assignedByAdmin Admin?   @relation("AssignmentsByAdmin", fields: [assignedBy], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([divisionId, userId])
  @@index([divisionId])
  @@index([userId])
  @@index([assignedBy])
  @@map("division_assignment")
}

model Match {
  id            String   @id @default(cuid())
  divisionId    String?
  sport         String
  matchType     String
  playerScore   Int?
  opponentScore Int?
  outcome       String?
  matchDate     DateTime @default(now())
  location      String?
  notes         String?
  duration      Int?

  division     Division?          @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  participants MatchParticipant[]
  stats        MatchStats?
  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([divisionId])
  @@index([sport])
  @@index([matchDate])
}

//TO DO - use this and link with seasonmembership
model MatchParticipant {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  isStarter Boolean  @default(true)
  team      String?
  createdAt DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@index([userId])
  @@index([matchId])
}

model MatchStats {
  id                     String   @id @default(cuid())
  matchId                String   @unique
  playerAces             Int?
  playerUnforcedErrors   Int?
  playerWinners          Int?
  playerDoubleFaults     Int?
  opponentAces           Int?
  opponentUnforcedErrors Int?
  opponentWinners        Int?
  opponentDoubleFaults   Int?
  rallyCount             Int?
  longestRally           Int?
  breakPointsConverted   Int?
  breakPointsTotal       Int?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  match                  Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
}

model Achievement {
  id               String            @id @default(cuid())
  title            String
  description      String
  icon             String?
  category         String
  requirement      Json?
  points           Int               @default(0)
  isActive         Boolean           @default(true)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  userAchievements UserAchievement[]

  @@index([category])
  @@index([isActive])
}

model UserAchievement {
  id            String      @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime    @default(now())
  progress      Json?
  isCompleted   Boolean     @default(true)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([achievementId])
}

model Thread {
  id        String  @id @default(cuid())
  name      String? // Only for group chats
  avatarUrl String?
  isGroup   Boolean @default(false)

  divisionId String?
  division   Division? @relation("DivisionThreads", fields: [divisionId], references: [id])

  members  UserThread[]
  messages Message[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  notifications Notification[]
}

model UserThread {
  id       String   @id @default(cuid())
  thread   Thread   @relation(fields: [threadId], references: [id])
  threadId String
  user     User     @relation(fields: [userId], references: [id])
  userId   String
  role     String?
  joinedAt DateTime @default(now())

  @@unique([threadId, userId]) // Prevent duplicate memberships
}

model Message {
  id       String @id @default(cuid())
  thread   Thread @relation(fields: [threadId], references: [id])
  threadId String
  sender   User   @relation(fields: [senderId], references: [id])
  senderId String

  content String?

  // Reply/Quote/Forwarding
  repliesToId String?
  repliesTo   Message?  @relation("Replies", fields: [repliesToId], references: [id], onDelete: SetNull)
  repliedBy   Message[] @relation("Replies")

  // Message Management
  isEdited  Boolean @default(false)
  isDeleted Boolean @default(false)

  readBy    MessageReadBy[]
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([threadId, createdAt])
}

model MessageReadBy {
  id        String   @id @default(cuid())
  message   Message  @relation(fields: [messageId], references: [id])
  messageId String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  readAt    DateTime?

  @@unique([messageId, userId])
}

model Friendship {
  id          String           @id @default(cuid())
  requesterId String
  recipientId String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  respondedAt DateTime?

  requester User @relation("SentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient User @relation("ReceivedFriendRequests", fields: [recipientId], references: [id], onDelete: Cascade)

  @@unique([requesterId, recipientId])
  @@index([requesterId])
  @@index([recipientId])
  @@index([status])
  @@map("friendship")
}

model Favorite {
  id          String   @id @default(cuid())
  userId      String   // User who is making the favorite
  favoritedId String   // User who is being favorited
  createdAt   DateTime @default(now())

  user      User @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
  favorited User @relation("FavoritedUser", fields: [favoritedId], references: [id], onDelete: Cascade)

  @@unique([userId, favoritedId])
  @@index([userId])
  @@index([favoritedId])
  @@map("favorite")
}

model PairRequest {
  id          String            @id @default(cuid())
  requesterId String
  recipientId String
  seasonId    String
  message     String?
  status      PairRequestStatus
  createdAt   DateTime          @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  requester User   @relation("SentPairRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient User   @relation("ReceivedPairRequests", fields: [recipientId], references: [id], onDelete: Cascade)
  season    Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@index([requesterId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@map("pair_request")
}

model Partnership {
  id          String            @id @default(cuid())
  captainId   String            // Requester = Captain
  partnerId   String            // Recipient = Partner
  seasonId    String
  divisionId  String?
  pairRating  Int?
  status      PartnershipStatus @default(ACTIVE)
  createdAt   DateTime          @default(now())
  dissolvedAt DateTime?

  captain           User                @relation("PartnershipCaptain", fields: [captainId], references: [id], onDelete: Cascade)
  partner           User                @relation("PartnershipPartner", fields: [partnerId], references: [id], onDelete: Cascade)
  season            Season              @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division          Division?           @relation(fields: [divisionId], references: [id], onDelete: SetNull)
  withdrawalRequest WithdrawalRequest[]
  notifications Notification[]

  @@unique([captainId, seasonId])
  @@unique([partnerId, seasonId])
  @@index([seasonId])
  @@index([status])
  @@index([captainId])
  @@index([partnerId])
  @@map("partnership")
}

model SeasonInvitation {
  id          String                 @id @default(cuid())
  senderId    String
  recipientId String
  seasonId    String
  message     String?
  status      SeasonInvitationStatus
  createdAt   DateTime               @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  sender    User   @relation("SentSeasonInvitations", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User   @relation("ReceivedSeasonInvitations", fields: [recipientId], references: [id], onDelete: Cascade)
  season    Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  @@unique([senderId, recipientId, seasonId])
  @@index([senderId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@map("season_invitation")
}

model Notification {
  id               String           @id @unique @default(cuid())
  title            String?
  message          String
  category         NotificationCategory
  type             String?
  createdAt        DateTime         @default(now())
  
  seasonId         String?
  divisionId       String?
  matchId          String?
  userId           String?
  partnershipId    String?
  threadId         String?
  pairRequestId    String?
  withdrawalRequestId String?
  
  // Relations
  season           Season?           @relation(fields: [seasonId], references: [id])
  division         Division?         @relation(fields: [divisionId], references: [id])
  match            Match?            @relation(fields: [matchId], references: [id])
  user             User?             @relation(fields: [userId], references: [id])
  partnership      Partnership?      @relation(fields: [partnershipId], references: [id])
  thread           Thread?           @relation(fields: [threadId], references: [id])
  pairRequest      PairRequest?      @relation(fields: [pairRequestId], references: [id])
  withdrawalRequest WithdrawalRequest? @relation(fields: [withdrawalRequestId], references: [id])
  
  userNotifications UserNotification[]
  
  @@index([type])
  @@index([createdAt])
  @@map("notification")
}

model UserNotification {
  id             String       @id @unique @default(cuid())
  userId         String
  notificationId String
  read           Boolean      @default(false)
  archive        Boolean      @default(false)
  readAt         DateTime?

  notification   Notification @relation(fields: [notificationId], references: [id])
  user           User         @relation(fields: [userId], references: [id])

  @@unique([userId, notificationId])
  @@index([userId, read])
  @@index([userId, archive])
  @@map("user_notification")
}

enum NotificationCategory {
  DIVISION
  LEAGUE
  CHAT
  MATCH
  SEASON
  PAYMENT
  ADMIN
  GENERAL
}

enum PairRequestStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
  AUTO_DENIED
}

enum PartnershipStatus {
  ACTIVE
  DISSOLVED
  EXPIRED
}

enum Role {
  USER
  ADMIN
  SUPERADMIN
}

enum AdminStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum SeasonStatus {
  UPCOMING
  ACTIVE
  FINISHED
  CANCELLED
}

enum GenderRestriction {
  MALE
  FEMALE
  MIXED
  OPEN
}

enum GenderType {
  MALE
  FEMALE
  MIXED
}

enum MembershipStatus {
  PENDING
  ACTIVE
  FLAGGED
  INACTIVE
  REMOVED
}

enum Statuses {
  ACTIVE
  INACTIVE
  SUSPENDED
  UPCOMING
  ONGOING
  FINISHED
  CANCELLED
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DivisionLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum GameType {
  SINGLES
  DOUBLES
}

enum SportType {
  PADEL
  PICKLEBALL
  TENNIS
}

enum TierType {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

enum SeasonInvitationStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
}
