generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String          @id @default(cuid())
  name                String
  email               String          @unique
  emailVerified       Boolean         @default(false)
  image               String?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  displayUsername     String?
  username            String          @unique
  role                Role            @default(USER)
  dateOfBirth         DateTime?
  gender              String?
  area                String?
  completedOnboarding Boolean         @default(false)
  onboardingStep      OnboardingStep?
  lastActivityCheck   DateTime?
  lastLogin           DateTime?
  status              UserStatus      @default(ACTIVE)
  bio                 String?
  phoneNumber         String?
  admin               Admin?

  achievements       UserAchievement[]
  accounts           Account[]
  sessions           Session[]
  seasonMemberships  SeasonMembership[]
  payments           Payment[]
  matchParticipants  MatchParticipant[]
  processedRequests  WithdrawalRequest[] @relation("ProcessedByAdmin")
  withdrawalRequests WithdrawalRequest[] @relation("WithdrawalRequester")
  teamChangeRequests TeamChangeRequest[] @relation("TeamChangeRequester")

  divisionAssignments DivisionAssignment[] @relation("DivisionAssignments")

  // Pairing & Friendship Relations
  sentFriendRequests        Friendship[]       @relation("SentFriendRequests")
  receivedFriendRequests    Friendship[]       @relation("ReceivedFriendRequests")
  sentPairRequests          PairRequest[]      @relation("SentPairRequests")
  receivedPairRequests      PairRequest[]      @relation("ReceivedPairRequests")
  captainPartnerships       Partnership[]      @relation("PartnershipCaptain")
  partnerPartnerships       Partnership[]      @relation("PartnershipPartner")
  sentSeasonInvitations     SeasonInvitation[] @relation("SentSeasonInvitations")
  receivedSeasonInvitations SeasonInvitation[] @relation("ReceivedSeasonInvitations")
  matchComments             MatchComment[]

  // Favorite relations
  favoritesMade     Favorite[] @relation("UserFavorites")
  favoritedByOthers Favorite[] @relation("FavoritedUser")

  //Thread relations
  userThreads UserThread[]
  messages    Message[]

  // Questionnaire relations
  questionnaireResponses QuestionnaireResponse[]

  // Notification relations
  notifications           Notification[]
  userNotifications       UserNotification[]
  notificationPreferences NotificationPreference?
  pushTokens              UserPushToken[]

  // Admin-focused match management relations
  raisedDisputes     MatchDispute[]   @relation("RaisedDisputes")
  disputeComments    DisputeComment[] @relation("DisputeComments")
  defaultedMatches   MatchWalkover[]  @relation("DefaultedMatches")
  walkoverWins       MatchWalkover[]  @relation("WalkoverWins")
  reportedWalkovers  MatchWalkover[]  @relation("ReportedWalkovers")
  confirmedWalkovers MatchWalkover[]  @relation("ConfirmedWalkovers")
  penalties          PlayerPenalty[]  @relation("UserPenalties")

  // Rating system relations
  playerRatings     PlayerRating[]
  divisionStandings DivisionStanding[]

  // Inactivity tracking
  lastMatchDate       DateTime?
  inactivityWarningAt DateTime?
  markedInactiveAt    DateTime?
  inactivityExempt    Boolean              @default(false)
  statusChanges       PlayerStatusChange[]

  // Bug tracking relations
  bugReports       BugReport[]       @relation("BugReporter")
  bugComments      BugComment[]      @relation("BugCommentAuthor")
  bugStatusChanges BugStatusChange[] @relation("BugStatusChanger")

  // Match invitation system relations
  matchesCreated           Match[]           @relation("MatchCreator")
  matchResultsSubmitted    Match[]           @relation("MatchResultSubmitter")
  matchResultsConfirmed    Match[]           @relation("MatchResultConfirmer")
  matchesCancelled         Match[]           @relation("MatchCanceller")
  matchWalkoversRecorded   Match[]           @relation("MatchWalkoverRecorder")
  matchInvitationsSent     MatchInvitation[] @relation("MatchInvitationsSent")
  matchInvitationsReceived MatchInvitation[] @relation("MatchInvitationsReceived")

  // Bracket system relations
  bracketPlayer1 BracketMatch[] @relation("BracketPlayer1")
  bracketPlayer2 BracketMatch[] @relation("BracketPlayer2")

  // NEW: Match result relations (Best 6 system)
  matchResults         MatchResult[] @relation("PlayerMatchResults")
  opponentMatchResults MatchResult[] @relation("OpponentMatchResults")

  // User settings relation
  settings UserSettings?

  // Activity Feed relations
  feedPosts    FeedPost[]    @relation("FeedPostAuthor")
  feedLikes    FeedLike[]    @relation("FeedLikeUser")
  feedComments FeedComment[] @relation("FeedCommentAuthor")

  // User activity logs
  activityLogs UserActivityLog[] @relation("UserActivityLogs")

  @@index([email])
  @@index([lastMatchDate])
  @@index([username])
  @@index([status])
  @@index([completedOnboarding])
  @@index([createdAt])
  @@map("user")
}

model UserSettings {
  id               String   @id @default(cuid())
  userId           String   @unique
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  notifications    Boolean  @default(true)
  matchReminders   Boolean  @default(true)
  locationServices Boolean  @default(false)
  hapticFeedback   Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Self-assessed skill levels per sport
  tennisSkillLevel     SkillLevel?
  pickleballSkillLevel SkillLevel?
  padelSkillLevel      SkillLevel?

  @@index([userId])
  @@map("user_settings")
}

model Admin {
  id        String            @id @default(cuid())
  userId    String?           @unique
  status    AdminStatus       @default(PENDING)
  invitedBy String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  user      User?             @relation(fields: [userId], references: [id])
  invite    AdminInviteToken?

  // Relations
  leagues             League[]
  sponsorships        Sponsorship[]        @relation("SponsorshipCreatedBy")
  divisionsCreated    Division[]           @relation("DivisionCreatedBy")
  divisionsUpdated    Division[]           @relation("DivisionUpdatedBy")
  divisionAssignments DivisionAssignment[] @relation("AssignmentsByAdmin")

  // Admin-focused match management relations
  reviewedDisputes  MatchDispute[]     @relation("ReviewedDisputes")
  resolvedDisputes  MatchDispute[]     @relation("ResolvedDisputes")
  disputeNotes      DisputeAdminNote[] @relation("DisputeNotes")
  verifiedWalkovers MatchWalkover[]    @relation("VerifiedWalkovers")
  issuedPenalties   PlayerPenalty[]    @relation("IssuedPenalties")
  resolvedAppeals   PlayerPenalty[]    @relation("ResolvedAppeals")
  adminMatchActions MatchAdminAction[] @relation("AdminMatchActions")

  // Rating system relations
  ratingAdjustments    RatingAdjustment[]    @relation("RatingAdjustments")
  ratingParameters     RatingParameters[]    @relation("RatingParametersCreated")
  ratingRecalculations RatingRecalculation[] @relation("RatingRecalculations")
  seasonsLocked        SeasonLock[]          @relation("SeasonLockedBy")
  seasonsOverridden    SeasonLock[]          @relation("SeasonOverrideBy")

  // Inactivity system relations
  inactivitySettingsUpdated InactivitySettings[] @relation("InactivitySettingsUpdated")
  statusChangesTriggered    PlayerStatusChange[] @relation("StatusChangesTriggered")

  // Bug tracking relations
  assignedBugs       BugReport[]         @relation("BugAssignee")
  resolvedBugs       BugReport[]         @relation("BugResolver")
  bugDefaultSettings BugReportSettings[] @relation("BugDefaultAssignee")

  // Bracket system relations
  bracketsPublished Bracket[] @relation("BracketPublisher")

  // Team change request relations
  reviewedTeamChangeRequests TeamChangeRequest[] @relation("TeamChangeReviewer")

  // Message audit log
  messageLogs AdminMessageLog[]

  // General admin action logging
  adminLogs AdminLog[] @relation("AdminLogs")

  // Admin status change tracking
  statusChanges          AdminStatusChange[] @relation("AdminStatusChanges")
  triggeredStatusChanges AdminStatusChange[] @relation("AdminStatusChangesTriggered")
}

model AdminInviteToken {
  id        String   @id @default(cuid())
  adminId   String   @unique
  email     String
  token     String   @unique
  status    String   @default("PENDING")
  createdAt DateTime @default(now())
  expiresAt DateTime
  admin     Admin    @relation(fields: [adminId], references: [id])
}

// General admin action log for tracking all admin activities
model AdminLog {
  id          String          @id @default(cuid())
  adminId     String
  actionType  AdminActionType
  targetType  AdminTargetType
  targetId    String? // ID of the affected entity (player, league, match, etc.)
  description String // Human-readable description of the action
  oldValue    Json? // Previous state (for edit operations)
  newValue    Json? // New state (for edit operations)
  metadata    Json? // Additional context (IP address, user agent, etc.)
  createdAt   DateTime        @default(now())

  admin Admin @relation("AdminLogs", fields: [adminId], references: [id])

  @@index([adminId, createdAt(sort: Desc)])
  @@index([actionType, createdAt(sort: Desc)])
  @@index([targetType, targetId])
  @@index([createdAt(sort: Desc)])
  @@map("admin_log")
}

model UserActivityLog {
  id         Int            @id @default(autoincrement())
  userId     String
  actionType UserActionType
  targetType UserTargetType
  targetId   String?
  metadata   Json?
  ipAddress  String?
  createdAt  DateTime       @default(now())

  user User @relation("UserActivityLogs", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([targetId, createdAt(sort: Desc)])
  @@index([actionType, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("user_activity_log")
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("account")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("session")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String   
  status     String   @default("PENDING")
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

model QuestionnaireResponse {
  id          Int                  @id @default(autoincrement())
  userId      String
  sport       String
  qVersion    Int
  qHash       String
  answersJson Json
  startedAt   DateTime             @default(now())
  completedAt DateTime?
  result      InitialRatingResult?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sport, qVersion])
  @@index([qHash])
}

model InitialRatingResult {
  id         Int                   @id @default(autoincrement())
  responseId Int                   @unique
  source     String
  singles    Int?
  doubles    Int?
  rd         Int?
  confidence String?
  detail     Json?
  createdAt  DateTime              @default(now())
  response   QuestionnaireResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)
}

model League {
  id          String  @id @default(cuid())
  name        String  @db.VarChar(255)
  location    String?
  description String?

  status    Statuses  @default(UPCOMING)
  sportType SportType
  gameType  GameType

  createdById String?
  createdBy   Admin?  @relation(fields: [createdById], references: [id])

  seasons      Season[]      @relation("LeagueToSeason")
  sponsorships Sponsorship[]
  divisions    Division[]
  matches      Match[]       @relation("LeagueMatches")

  // Rating system relations
  ratingParameters RatingParameters[]

  // Inactivity system relations
  inactivitySettings InactivitySettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([location])
  @@index([status])
}

model Category {
  id   String  @id @default(cuid())
  name String? @db.VarChar(255)

  // Restrictions and Format
  genderRestriction GenderRestriction @default(OPEN)
  matchFormat       String? // e.g., Best of 3 sets
  gameType          GameType?
  genderCategory    GenderType?
  isActive          Boolean           @default(true)
  categoryOrder     Int               @default(0)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  seasons Season[]

  @@index([isActive])
}

model Sponsorship {
  id             String   @id @default(cuid())
  packageTier    TierType
  contractAmount Decimal? @db.Decimal(10, 2)
  sponsorRevenue Decimal? @db.Decimal(10, 2)
  sponsoredName  String?
  createdById    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships
  leagues   League[]
  createdBy Admin?     @relation("SponsorshipCreatedBy", fields: [createdById], references: [id])
  divisions Division[] @relation("DivisionSponsor")
  seasons   Season[]   @relation("SeasonSponsor")

  @@map("sponsorship")
}

model Season {
  id                  String    @id @default(cuid())
  name                String
  startDate           DateTime?
  endDate             DateTime?
  regiDeadline        DateTime?
  entryFee            Decimal   @db.Decimal(10, 2)
  description         String?
  registeredUserCount Int       @default(0)

  //Bools
  status             SeasonStatus @default(UPCOMING)
  isActive           Boolean      @default(false)
  paymentRequired    Boolean      @default(false)
  promoCodeSupported Boolean      @default(false)
  withdrawalEnabled  Boolean      @default(false)

  //Relations
  divisions          Division[]
  memberships        SeasonMembership[]
  payments           Payment[]
  promoCodes         PromoCode[]         @relation("SeasonPromoCodes")
  withdrawalRequests WithdrawalRequest[]
  teamChangeRequests TeamChangeRequest[]

  // Pairing Relations
  pairRequests      PairRequest[]
  partnerships      Partnership[]
  seasonInvitations SeasonInvitation[]

  leagues League[] @relation("LeagueToSeason")

  categoryId String?
  category   Category?    @relation(fields: [categoryId], references: [id])
  sponsorId  String?
  sponsor    Sponsorship? @relation("SeasonSponsor", fields: [sponsorId], references: [id], onDelete: SetNull)

  notifications Notification[]

  waitlistId String?
  waitlist   Waitlist? @relation

  // Rating system relations
  playerRatings     PlayerRating[]
  divisionStandings DivisionStanding[]
  ratingParameters  RatingParameters[]
  seasonLock        SeasonLock?
  matches           Match[]            @relation("SeasonMatches")

  // Inactivity system relations
  inactivitySettings InactivitySettings?

  // Bracket system relations
  brackets Bracket[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([isActive])
  @@index([sponsorId])
}

model Waitlist {
  id              String         @id @default(cuid())
  seasonId        String         @unique
  season          Season         @relation(fields: [seasonId], references: [id])
  enabled         Boolean        @default(false)
  maxParticipants Int?
  waitlistedUsers WaitlistUser[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WaitlistUser {
  id                   String   @id @default(cuid())
  waitlistId           String
  userId               String
  waitlistDate         DateTime @default(now())
  promotedToRegistered Boolean  @default(false)

  waitlist Waitlist @relation(fields: [waitlistId], references: [id])

  @@unique([waitlistId, userId])
  @@index([waitlistId])
  @@index([userId])
}

model PromoCode {
  id            String    @id @default(cuid())
  code          String    @unique
  description   String?
  discountValue Decimal   @db.Decimal(10, 2)
  isPercentage  Boolean   @default(false) // True for %, false for fixed amount
  isActive      Boolean   @default(true)
  expiresAt     DateTime?

  seasons Season[] @relation("SeasonPromoCodes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WithdrawalRequest {
  id                 String           @id @default(cuid())
  userId             String
  reason             String
  requestDate        DateTime         @default(now())
  status             WithdrawalStatus @default(PENDING)
  processedByAdminId String?
  partnershipId      String? // For partner change requests

  user             User           @relation("WithdrawalRequester", fields: [userId], references: [id])
  processedByAdmin User?          @relation("ProcessedByAdmin", fields: [processedByAdminId], references: [id])
  seasonId         String
  season           Season         @relation(fields: [seasonId], references: [id])
  partnership      Partnership?   @relation(fields: [partnershipId], references: [id])
  notifications    Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model TeamChangeRequest {
  id                  String                  @id @default(cuid())
  userId              String
  currentDivisionId   String
  requestedDivisionId String
  seasonId            String
  reason              String?
  status              TeamChangeRequestStatus @default(PENDING)
  reviewedByAdminId   String?
  reviewedAt          DateTime?
  adminNotes          String?

  user              User     @relation("TeamChangeRequester", fields: [userId], references: [id])
  currentDivision   Division @relation("CurrentDivisionRequests", fields: [currentDivisionId], references: [id])
  requestedDivision Division @relation("RequestedDivisionRequests", fields: [requestedDivisionId], references: [id])
  season            Season   @relation(fields: [seasonId], references: [id])
  reviewedByAdmin   Admin?   @relation("TeamChangeReviewer", fields: [reviewedByAdminId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([seasonId])
  @@index([status])
  @@index([currentDivisionId])
  @@index([requestedDivisionId])
}

model Division {
  id             String         @id @default(cuid())
  name           String
  description    String?
  level          DivisionLevel?
  gameType       GameType
  genderCategory GenderType?

  // capacities
  maxSinglesPlayers Int?
  maxDoublesTeams   Int?

  // denormalized counts
  currentSinglesCount Int? @default(0)
  currentDoublesCount Int? @default(0)

  autoAssignmentEnabled Boolean @default(false)
  isActiveDivision      Boolean @default(true)
  pointsThreshold       Int?

  // Sponsorship fields
  divisionSponsorId     String? // division_sponsor_id
  divisionSponsor       Sponsorship? @relation("DivisionSponsor", fields: [divisionSponsorId], references: [id], onDelete: SetNull)
  sponsoredDivisionName String? // sponsored_division_name
  prizePoolTotal        Decimal?     @db.Decimal(10, 2) // prize_pool_total

  // audit â€” Admin FKs
  createdByAdminId     String?
  createdByAdmin       Admin?  @relation("DivisionCreatedBy", fields: [createdByAdminId], references: [id], onDelete: SetNull)
  lastUpdatedByAdminId String?
  lastUpdatedByAdmin   Admin?  @relation("DivisionUpdatedBy", fields: [lastUpdatedByAdminId], references: [id], onDelete: SetNull)

  // Relations
  matches           Match[]
  assignments       DivisionAssignment[] // Player assignments tracking
  seasonMemberships SeasonMembership[]   @relation("SeasonMembershipDivision")
  seasonId          String
  season            Season               @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  leagueId          String
  league            League               @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  threads           Thread[]             @relation("DivisionThreads")
  notifications     Notification[]

  // Pairing Relations
  partnerships Partnership[]

  // Rating system relations
  playerRatings     PlayerRating[]
  divisionStandings DivisionStanding[]

  // Bracket system relations
  brackets Bracket[]

  // Team change request relations
  currentDivisionRequests   TeamChangeRequest[] @relation("CurrentDivisionRequests")
  requestedDivisionRequests TeamChangeRequest[] @relation("RequestedDivisionRequests")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([seasonId, name])
  @@index([seasonId])
  @@index([leagueId])
  @@index([isActiveDivision])
  @@index([divisionSponsorId])
  @@map("division")
}

model SeasonMembership {
  id               String           @id @default(cuid())
  userId           String
  seasonId         String
  divisionId       String?
  status           MembershipStatus @default(PENDING)
  joinedAt         DateTime         @default(now())
  withdrawalReason String? // For handling "View Withdrawal Request"
  paymentStatus    PaymentStatus    @default(PENDING)

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  season   Season    @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division Division? @relation("SeasonMembershipDivision", fields: [divisionId], references: [id], onDelete: Cascade)
  payments Payment[]

  @@unique([userId, seasonId, divisionId])
  @@index([userId])
  @@index([seasonId])
  @@index([divisionId, status])
  @@index([userId, seasonId])
  @@index([seasonId, status])
}

model DivisionAssignment {
  id                String   @id @default(cuid())
  divisionId        String
  userId            String
  assignedBy        String? // Admin ID who made the assignment
  assignedAt        DateTime @default(now())
  reassignmentCount Int      @default(0) // Track how many times player was moved
  notes             String? // Admin notes for assignment

  // Relations
  division        Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  user            User     @relation("DivisionAssignments", fields: [userId], references: [id], onDelete: Cascade)
  assignedByAdmin Admin?   @relation("AssignmentsByAdmin", fields: [assignedBy], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([divisionId, userId])
  @@index([divisionId])
  @@index([userId])
  @@index([assignedBy])
  @@map("division_assignment")
}

model Match {
  id            String    @id @default(cuid())
  divisionId    String?
  leagueId      String?
  seasonId      String?
  sport         String
  matchType     MatchType @default(SINGLES)
  playerScore   Int?
  opponentScore Int?
  outcome       String?
  matchDate     DateTime  @default(now())
  location      String?
  venue         String? // Specific venue name
  notes         String?
  duration      Int?
  courtBooked   Boolean?

  // Fee fields
  fee       MatchFeeType? @default(FREE)
  feeAmount Decimal?      @db.Decimal(10, 2)

  // Match format
  format   MatchFormat @default(STANDARD)
  isOneSet Boolean     @default(false)

  // Creator tracking
  createdById String?

  // Enhanced fields for admin management
  status     MatchStatus @default(SCHEDULED)
  isWalkover Boolean     @default(false)
  isDisputed Boolean     @default(false)
  adminNotes String?

  // Team-based scoring (for doubles)
  team1Score Int?
  team2Score Int?
  setScores  Json? // Detailed set scores

  // Result submission tracking
  resultSubmittedById String?
  resultSubmittedAt   DateTime?
  resultConfirmedById String?
  resultConfirmedAt   DateTime?

  resultEvidence String?
  isAutoApproved Boolean @default(false)

  // Cancellation tracking
  cancellationRequestedAt DateTime?
  isLateCancellation      Boolean             @default(false)
  cancellationReason      CancellationReason?
  cancelledById           String?
  cancelledAt             DateTime?
  cancellationComment     String?

  // Walkover tracking
  walkoverReason       WalkoverReason?
  walkoverRecordedById String?

  // Reschedule tracking
  rescheduledFromId String? @unique
  rescheduleCount   Int     @default(0)

  // Standard walkover scores
  walkoverScore Json?

  // Admin review
  requiresAdminReview Boolean @default(false)

  // Friendly match moderation (for admin visibility)
  isHiddenFromPublic Boolean              @default(false)
  hiddenAt           DateTime?
  hiddenByAdminId    String?
  hiddenReason       String?
  isReportedForAbuse Boolean              @default(false)
  reportedAt         DateTime?
  reportedByAdminId  String?
  reportReason       String?
  reportCategory     MatchReportCategory?

  // NEW: Set 3 format toggle
  set3Format Set3Format? // MATCH_TIEBREAK, FULL_SET

  // Friendly match fields
  isFriendly        Boolean            @default(false)
  genderRestriction GenderRestriction? // MALE, FEMALE, OPEN (null = OPEN/All)
  skillLevels       String[] // Array: ["BEGINNER", "IMPROVER", "INTERMEDIATE", "UPPER_INTERMEDIATE", "EXPERT"]

  // Friendly match request fields
  isFriendlyRequest  Boolean           @default(false)
  requestExpiresAt   DateTime?
  requestStatus      InvitationStatus? // PENDING, ACCEPTED, DECLINED, EXPIRED
  requestRecipientId String?

  // Relations
  division           Division? @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  league             League?   @relation("LeagueMatches", fields: [leagueId], references: [id], onDelete: SetNull)
  season             Season?   @relation("SeasonMatches", fields: [seasonId], references: [id], onDelete: SetNull)
  createdBy          User?     @relation("MatchCreator", fields: [createdById], references: [id], onDelete: SetNull)
  resultSubmittedBy  User?     @relation("MatchResultSubmitter", fields: [resultSubmittedById], references: [id], onDelete: SetNull)
  resultConfirmedBy  User?     @relation("MatchResultConfirmer", fields: [resultConfirmedById], references: [id], onDelete: SetNull)
  cancelledBy        User?     @relation("MatchCanceller", fields: [cancelledById], references: [id], onDelete: SetNull)
  walkoverRecordedBy User?     @relation("MatchWalkoverRecorder", fields: [walkoverRecordedById], references: [id], onDelete: SetNull)

  comments      MatchComment[]
  participants  MatchParticipant[]
  invitations   MatchInvitation[]
  notifications Notification[]

  // Admin-focused relations
  disputes     MatchDispute[]
  walkover     MatchWalkover?
  adminActions MatchAdminAction[]
  penalties    PlayerPenalty[]    @relation("MatchPenalties")

  // Rating system relations
  scores        MatchScore[]
  ratingHistory RatingHistory[]

  // NEW: Best 6 system relations
  matchResults     MatchResult[]
  pickleballScores PickleballGameScore[]

  // Inactivity system relations
  statusChanges PlayerStatusChange[]

  // Reschedule relation
  rescheduledFrom Match? @relation("Reschedule", fields: [rescheduledFromId], references: [id])
  rescheduledTo   Match? @relation("Reschedule")

  // Bracket relation
  bracketMatch BracketMatch?

  // Chat messages relation
  messages Message[]

  // Admin message audit logs
  adminMessageLogs AdminMessageLog[]

  // Activity Feed relation
  feedPosts FeedPost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([divisionId])
  @@index([leagueId])
  @@index([seasonId])
  @@index([sport])
  @@index([matchDate])
  @@index([status])
  @@index([isDisputed])
  @@index([matchType])
  @@index([isLateCancellation])
  @@index([createdById])
  @@index([format])
  @@index([requiresAdminReview])
  @@index([isHiddenFromPublic])
  @@index([isReportedForAbuse])
  @@index([isFriendly])
  @@index([genderRestriction])
  @@index([isFriendlyRequest])
  @@index([requestStatus])
  @@index([requestExpiresAt])
  @@index([divisionId, seasonId, status])
}

model MatchParticipant {
  id        String  @id @default(cuid())
  matchId   String
  userId    String
  isStarter Boolean @default(true)
  team      String? // "team1" or "team2" for doubles

  // Role and invitation tracking
  role             ParticipantRole  @default(INVITED)
  invitationStatus InvitationStatus @default(PENDING)
  acceptedAt       DateTime?

  // Attendance tracking
  didAttend Boolean?
  arrivedAt DateTime?
  wasLate   Boolean   @default(false)

  createdAt DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@index([userId])
  @@index([matchId])
  @@index([role])
  @@index([invitationStatus])
}

model MatchInvitation {
  id            String           @id @default(cuid())
  matchId       String
  inviterId     String
  inviteeId     String
  // Invitation details
  status        InvitationStatus @default(PENDING)
  message       String?
  declineReason String?

  // Timing
  sentAt      DateTime  @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  // Reminders
  reminderSentAt DateTime?
  reminderCount  Int       @default(0)

  // Relations
  match   Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  inviter User  @relation("MatchInvitationsSent", fields: [inviterId], references: [id], onDelete: Cascade)
  invitee User  @relation("MatchInvitationsReceived", fields: [inviteeId], references: [id], onDelete: Cascade)

  @@unique([matchId, inviteeId])
  @@index([matchId])
  @@index([inviterId])
  @@index([inviteeId])
  @@index([status])
  @@index([expiresAt])
  @@map("match_invitation")
}

model MatchComment {
  id        String   @id @default(cuid())
  matchId   String
  userId    String
  comment   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([matchId])
  @@index([userId])
  @@index([createdAt])
}

// =============================================
// FINALS BRACKET SYSTEM MODELS
// =============================================

model Bracket {
  id         String @id @default(cuid())
  seasonId   String
  divisionId String

  bracketName String // "Division A Finals"
  bracketType BracketType @default(SINGLE_ELIMINATION)

  status   BracketStatus @default(DRAFT)
  isLocked Boolean       @default(false) // Once locked, seeding can't change

  seedingSource SeedingSource @default(STANDINGS)
  numPlayers    Int           @default(8)

  // Scheduling
  startDate DateTime?
  endDate   DateTime?

  // Publication
  publishedAt   DateTime?
  publishedById String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  season      Season         @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division    Division       @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  publishedBy Admin?         @relation("BracketPublisher", fields: [publishedById], references: [id])
  rounds      BracketRound[]
  matches     BracketMatch[]

  @@unique([seasonId, divisionId])
  @@index([status])
  @@index([seasonId])
  @@index([divisionId])
  @@map("bracket")
}

model BracketRound {
  id        String @id @default(cuid())
  bracketId String

  roundNumber Int // 1 = First round, higher = later rounds
  roundName   String // "Finals", "Semi-Finals", "Quarter-Finals"
  startDate   DateTime?
  endDate     DateTime?

  createdAt DateTime @default(now())

  // Relations
  bracket Bracket        @relation(fields: [bracketId], references: [id], onDelete: Cascade)
  matches BracketMatch[]

  @@unique([bracketId, roundNumber])
  @@index([bracketId])
  @@map("bracket_round")
}

model BracketMatch {
  id        String @id @default(cuid())
  bracketId String
  roundId   String

  matchNumber Int // Position in bracket (1-N per round)
  seed1       Int? // Seeding of player/team 1
  seed2       Int? // Seeding of player/team 2

  // Participants (for singles)
  player1Id String?
  player2Id String?

  // For doubles - partnership IDs
  team1Id String?
  team2Id String?

  // Link to actual played match
  matchId String? @unique

  // Winner
  winnerId String? // User ID or Partnership ID

  // For double elimination: where does loser go?
  nextMatchId      String? // Winner advances to this match
  loserNextMatchId String? // Loser goes to this match (double elim)

  status        BracketMatchStatus @default(PENDING)
  scheduledTime DateTime?
  courtLocation String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  bracket Bracket      @relation(fields: [bracketId], references: [id], onDelete: Cascade)
  round   BracketRound @relation(fields: [roundId], references: [id], onDelete: Cascade)
  player1 User?        @relation("BracketPlayer1", fields: [player1Id], references: [id])
  player2 User?        @relation("BracketPlayer2", fields: [player2Id], references: [id])
  match   Match?       @relation(fields: [matchId], references: [id])

  @@index([bracketId])
  @@index([roundId])
  @@index([status])
  @@map("bracket_match")
}

// =============================================
// END FINALS BRACKET SYSTEM MODELS
// =============================================

// =============================================
// ADMIN-FOCUSED MATCH MANAGEMENT MODELS
// =============================================

model MatchDispute {
  id              String          @id @default(cuid())
  matchId         String          @unique
  raisedByUserId  String
  disputeCategory DisputeCategory
  disputeComment  String
  disputerScore   Json?
  evidenceUrl     String?
  submittedAt     DateTime        @default(now())

  // Admin resolution fields
  adminResolution   String?
  resolutionAction  DisputeResolutionAction?
  finalScore        Json?
  resolvedAt        DateTime?
  status            DisputeStatus            @default(OPEN)
  priority          DisputePriority          @default(NORMAL)
  flaggedForReview  Boolean                  @default(false)
  reviewedByAdminId String?
  resolvedByAdminId String?

  // Relations
  match           Match              @relation(fields: [matchId], references: [id], onDelete: Cascade)
  raisedByUser    User               @relation("RaisedDisputes", fields: [raisedByUserId], references: [id])
  reviewedByAdmin Admin?             @relation("ReviewedDisputes", fields: [reviewedByAdminId], references: [id])
  resolvedByAdmin Admin?             @relation("ResolvedDisputes", fields: [resolvedByAdminId], references: [id])
  adminNotes      DisputeAdminNote[]
  comments        DisputeComment[]
  penalties       PlayerPenalty[]    @relation("DisputePenalties")

  @@index([matchId])
  @@index([raisedByUserId])
  @@index([status])
  @@index([priority])
  @@index([reviewedByAdminId])
  @@map("match_dispute")
}

model DisputeAdminNote {
  id             String   @id @default(cuid())
  disputeId      String
  adminId        String
  note           String
  isInternalOnly Boolean  @default(true)
  createdAt      DateTime @default(now())

  dispute MatchDispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  admin   Admin        @relation("DisputeNotes", fields: [adminId], references: [id])

  @@index([disputeId, createdAt(sort: Desc)])
  @@map("dispute_admin_note")
}

model DisputeComment {
  id          String   @id @default(cuid())
  disputeId   String
  senderId    String
  comment     String
  attachments Json?
  createdAt   DateTime @default(now())

  dispute MatchDispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender  User         @relation("DisputeComments", fields: [senderId], references: [id])

  @@index([disputeId, createdAt(sort: Asc)])
  @@map("dispute_comment")
}

model MatchWalkover {
  id                   String         @id @default(cuid())
  matchId              String         @unique
  walkoverFlag         Boolean        @default(true)
  walkoverReason       WalkoverReason
  walkoverReasonDetail String?
  defaultingPlayerId   String
  winningPlayerId      String
  reportedBy           String
  confirmedBy          String?
  adminVerified        Boolean        @default(false)
  adminVerifiedBy      String?
  adminVerifiedAt      DateTime?
  penaltyApplied       Boolean        @default(false)
  penaltyType          PenaltyType?
  penaltyDetails       String?
  penaltyId            String?
  createdAt            DateTime       @default(now())

  match            Match          @relation(fields: [matchId], references: [id], onDelete: Cascade)
  defaultingPlayer User           @relation("DefaultedMatches", fields: [defaultingPlayerId], references: [id])
  winningPlayer    User           @relation("WalkoverWins", fields: [winningPlayerId], references: [id])
  reporter         User           @relation("ReportedWalkovers", fields: [reportedBy], references: [id])
  confirmer        User?          @relation("ConfirmedWalkovers", fields: [confirmedBy], references: [id])
  verifiedByAdmin  Admin?         @relation("VerifiedWalkovers", fields: [adminVerifiedBy], references: [id])
  penalty          PlayerPenalty? @relation(fields: [penaltyId], references: [id])

  @@index([matchId])
  @@index([defaultingPlayerId])
  @@index([winningPlayerId])
  @@index([adminVerified])
  @@map("match_walkover")
}

model PlayerPenalty {
  id                    String          @id @default(cuid())
  userId                String
  penaltyType           PenaltyType
  severity              PenaltySeverity
  relatedMatchId        String?
  relatedDisputeId      String?
  pointsDeducted        Int?
  suspensionDays        Int?
  suspensionStartDate   DateTime?
  suspensionEndDate     DateTime?
  issuedByAdminId       String
  reason                String
  evidenceUrl           String?
  status                PenaltyStatus   @default(ACTIVE)
  appealSubmittedAt     DateTime?
  appealReason          String?
  appealResolvedBy      String?
  appealResolvedAt      DateTime?
  appealResolutionNotes String?
  expiresAt             DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  user                  User            @relation("UserPenalties", fields: [userId], references: [id])
  relatedMatch          Match?          @relation("MatchPenalties", fields: [relatedMatchId], references: [id])
  relatedDispute        MatchDispute?   @relation("DisputePenalties", fields: [relatedDisputeId], references: [id])
  issuedByAdmin         Admin           @relation("IssuedPenalties", fields: [issuedByAdminId], references: [id])
  appealResolvedByAdmin Admin?          @relation("ResolvedAppeals", fields: [appealResolvedBy], references: [id])
  walkovers             MatchWalkover[]

  @@index([userId, status])
  @@index([penaltyType])
  @@index([status])
  @@index([issuedByAdminId])
  @@index([expiresAt])
  @@map("player_penalty")
}

model MatchAdminAction {
  id                     String               @id @default(cuid())
  matchId                String
  adminId                String
  actionType             MatchAdminActionType
  oldValue               Json?
  newValue               Json?
  reason                 String
  affectedUserIds        Json?
  triggeredRecalculation Boolean              @default(false)
  recalculationDetails   Json?
  notifiedUsers          Json?
  ipAddress              String?
  createdAt              DateTime             @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  admin Admin @relation("AdminMatchActions", fields: [adminId], references: [id])

  @@index([matchId, createdAt(sort: Desc)])
  @@index([adminId, createdAt(sort: Desc)])
  @@index([actionType])
  @@map("match_admin_action")
}

// =============================================
// END ADMIN-FOCUSED MATCH MANAGEMENT MODELS
// =============================================

// =============================================
// RATING SYSTEM MODELS
// =============================================

model PlayerRating {
  id         String    @id @default(cuid())
  userId     String
  seasonId   String
  divisionId String?
  sport      SportType
  gameType   GameType

  // Core rating fields
  currentRating   Int
  ratingDeviation Int?
  volatility      Float?

  // Status
  isProvisional Boolean @default(true)
  matchesPlayed Int     @default(0)

  // Tracking
  lastMatchId    String?
  lastUpdatedAt  DateTime  @updatedAt
  peakRating     Int?
  peakRatingDate DateTime?
  lowestRating   Int?

  createdAt DateTime @default(now())

  // Relations
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  season      Season             @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division    Division?          @relation(fields: [divisionId], references: [id], onDelete: SetNull)
  history     RatingHistory[]
  adjustments RatingAdjustment[]

  @@unique([userId, seasonId, gameType])
  @@index([seasonId, divisionId])
  @@index([currentRating])
  @@index([isProvisional])
  @@index([userId])
  @@map("player_rating")
}

model RatingHistory {
  id             String  @id @default(cuid())
  playerRatingId String
  matchId        String?

  // Rating change
  ratingBefore Int
  ratingAfter  Int
  delta        Int

  // RD change (for Glicko)
  rdBefore Int?
  rdAfter  Int?

  // Reason
  reason RatingChangeReason
  notes  String?

  createdAt DateTime @default(now())

  // Relations
  playerRating PlayerRating @relation(fields: [playerRatingId], references: [id], onDelete: Cascade)
  match        Match?       @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([playerRatingId, createdAt(sort: Desc)])
  @@index([matchId])
  @@map("rating_history")
}

// FOR SINGLES ?
model MatchScore {
  id        String @id @default(cuid())
  matchId   String
  setNumber Int

  // Scores per side
  player1Games Int
  player2Games Int

  // Tiebreak details
  hasTiebreak     Boolean @default(false)
  player1Tiebreak Int?
  player2Tiebreak Int?

  // NEW: Distinguish tiebreak types
  tiebreakType TiebreakType? // STANDARD_7PT, MATCH_10PT

  createdAt DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, setNumber])
  @@index([matchId])
  @@map("match_score")
}

// =============================================
// MATCH RESULT TRACKING (Best 6 System)
// =============================================

model MatchResult {
  id         String @id @default(cuid())
  matchId    String
  playerId   String
  opponentId String

  // Sport and match info
  sportType SportType
  gameType  GameType
  isWin     Boolean

  // Points and metrics (SPEC-COMPLIANT)
  matchPoints         Int // 1-5 points per match
  participationPoints Int @default(1)
  setsWonPoints       Int // 0-2 for sets/games won
  winBonusPoints      Int @default(0) // 0 or 2

  // Margin for tiebreaking
  margin Int // Games/points differential

  // Match details
  setsWon   Int
  setsLost  Int
  gamesWon  Int // Tennis/Padel: game count, Pickleball: point count
  gamesLost Int

  // Timestamps
  datePlayed DateTime
  createdAt  DateTime @default(now())

  // CRITICAL: Best 6 System Fields
  countsForStandings Boolean @default(false)
  resultSequence     Int? // 1-6 if counted, null otherwise

  // Relations
  match    Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player   User  @relation("PlayerMatchResults", fields: [playerId], references: [id], onDelete: Cascade)
  opponent User  @relation("OpponentMatchResults", fields: [opponentId], references: [id], onDelete: Cascade)

  @@unique([matchId, playerId])
  @@index([playerId, datePlayed])
  @@index([playerId, countsForStandings])
  @@index([playerId, resultSequence])
  @@index([matchId])
  @@map("match_result")
}

// =============================================
// PICKLEBALL SCORING
// =============================================

model PickleballGameScore {
  id         String @id @default(cuid())
  matchId    String
  gameNumber Int // 1, 2, or 3

  player1Points Int
  player2Points Int

  createdAt DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, gameNumber])
  @@index([matchId])
  @@map("pickleball_game_score")
}

model DivisionStanding {
  id         String @id @default(cuid())
  divisionId String
  seasonId   String

  // Player or Partnership
  userId        String?
  partnershipId String?

  // Core standings
  rank             Int
  wins             Int @default(0)
  losses           Int @default(0)
  matchesPlayed    Int @default(0)
  matchesScheduled Int @default(9)

  // NEW: Spec-compliant points (from Best 6 only)
  totalPoints Int @default(0) // Max 30

  // NEW: Best 6 tracking
  countedWins   Int @default(0) // Wins in Best 6
  countedLosses Int @default(0) // Losses in Best 6

  // Match record breakdown (all matches)
  setsWon   Int @default(0)
  setsLost  Int @default(0)
  gamesWon  Int @default(0) // Games for Tennis/Padel, Points for Pickleball
  gamesLost Int @default(0)

  // NEW: Best 6 specific metrics (for tiebreakers)
  best6SetsWon    Int @default(0)
  best6SetsTotal  Int @default(0)
  best6GamesWon   Int @default(0)
  best6GamesTotal Int @default(0)

  // Tie-breaker data (H2H uses ALL matches)
  headToHead Json?

  // Tracking
  lastCalculatedAt DateTime @default(now())
  isLocked         Boolean  @default(false)

  // DEPRECATED (keep for migration, remove later)
  winPoints       Int @default(0)
  setPoints       Int @default(0)
  completionBonus Int @default(0)
  setDifferential Int @default(0)

  // Relations
  division    Division     @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  season      Season       @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  user        User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  partnership Partnership? @relation(fields: [partnershipId], references: [id], onDelete: Cascade)

  @@unique([divisionId, seasonId, userId])
  @@unique([divisionId, seasonId, partnershipId])
  @@index([divisionId, rank])
  @@index([seasonId])
  @@index([totalPoints(sort: Desc)])
  @@index([divisionId, seasonId])
  @@map("division_standing")
}

model RatingAdjustment {
  id             String @id @default(cuid())
  playerRatingId String
  adminId        String

  // Adjustment details
  adjustmentType AdjustmentType
  ratingBefore   Int
  ratingAfter    Int
  delta          Int

  // Documentation
  reason        String
  attachmentUrl String?
  internalNotes String?

  // Notification tracking
  playerNotified Boolean   @default(false)
  notifiedAt     DateTime?

  // Audit
  createdAt DateTime @default(now())
  ipAddress String?

  // Relations
  playerRating PlayerRating @relation(fields: [playerRatingId], references: [id], onDelete: Cascade)
  admin        Admin        @relation("RatingAdjustments", fields: [adminId], references: [id])

  @@index([playerRatingId, createdAt(sort: Desc)])
  @@index([adminId])
  @@map("rating_adjustment")
}

model RatingParameters {
  id String @id @default(cuid())

  // Scope
  leagueId String?
  seasonId String?

  // Core parameters
  initialRating Int @default(1500)
  initialRD     Int @default(350)

  // K-factors
  kFactorNew         Float @default(40)
  kFactorEstablished Float @default(20)
  kFactorThreshold   Int   @default(30)

  // Weightings
  singlesWeight     Float @default(1.0)
  doublesWeight     Float @default(1.0)
  oneSetMatchWeight Float @default(0.5)

  // Special cases
  walkoverWinImpact  Float @default(0.5)
  walkoverLossImpact Float @default(1.0)

  // Provisional settings
  provisionalThreshold Int @default(10)

  // Versioning
  version        Int       @default(1)
  effectiveFrom  DateTime
  effectiveUntil DateTime?
  isActive       Boolean   @default(true)

  // Audit
  createdByAdminId String
  createdAt        DateTime @default(now())
  notes            String?

  // Relations
  league    League? @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  season    Season? @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  createdBy Admin   @relation("RatingParametersCreated", fields: [createdByAdminId], references: [id])

  @@index([leagueId, isActive])
  @@index([seasonId, isActive])
  @@index([effectiveFrom])
  @@map("rating_parameters")
}

model RatingRecalculation {
  id String @id @default(cuid())

  // Scope
  scope      RecalculationScope
  matchId    String?
  userId     String?
  divisionId String?
  seasonId   String?
  leagueId   String?

  // Execution
  status             RecalculationStatus @default(PENDING)
  initiatedByAdminId String

  // Preview data
  affectedPlayersCount Int?
  changesPreview       Json?

  // Execution timing
  previewGeneratedAt DateTime?
  appliedAt          DateTime?
  failedAt           DateTime?
  errorMessage       String?

  // Audit
  createdAt DateTime @default(now())

  // Relations
  initiatedBy Admin @relation("RatingRecalculations", fields: [initiatedByAdminId], references: [id])

  @@index([status])
  @@index([initiatedByAdminId])
  @@index([createdAt(sort: Desc)])
  @@map("rating_recalculation")
}

model SeasonLock {
  id       String @id @default(cuid())
  seasonId String @unique

  // Lock state
  isLocked        Boolean  @default(true)
  lockedAt        DateTime @default(now())
  lockedByAdminId String

  // Export
  finalExportUrl    String?
  exportGeneratedAt DateTime?

  // Override tracking
  overrideAllowed   Boolean   @default(false)
  overrideReason    String?
  overrideByAdminId String?
  overrideAt        DateTime?

  // Relations
  season     Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  lockedBy   Admin  @relation("SeasonLockedBy", fields: [lockedByAdminId], references: [id])
  overrideBy Admin? @relation("SeasonOverrideBy", fields: [overrideByAdminId], references: [id])

  @@index([seasonId])
  @@map("season_lock")
}

// =============================================
// END RATING SYSTEM MODELS
// =============================================

// =============================================
// INACTIVITY SYSTEM MODELS
// =============================================

model InactivitySettings {
  id String @id @default(cuid())

  // Scope
  leagueId String? @unique
  seasonId String? @unique

  // Configuration
  inactivityThresholdDays Int  @default(14)
  warningThresholdDays    Int?

  // Behavior
  autoMarkInactive   Boolean @default(true)
  excludeFromPairing Boolean @default(true)
  sendReminderEmail  Boolean @default(true)
  reminderDaysBefore Int?    @default(3)

  // Audit
  updatedByAdminId String
  updatedAt        DateTime @updatedAt
  createdAt        DateTime @default(now())

  // Relations
  league    League? @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  season    Season? @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  updatedBy Admin   @relation("InactivitySettingsUpdated", fields: [updatedByAdminId], references: [id])

  @@index([leagueId])
  @@index([seasonId])
  @@map("inactivity_settings")
}

model PlayerStatusChange {
  id     String @id @default(cuid())
  userId String

  // Change details
  previousStatus UserStatus
  newStatus      UserStatus
  reason         StatusChangeReason
  notes          String?

  // Trigger
  triggeredById String?
  matchId       String?

  createdAt DateTime @default(now())

  // Relations
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  triggeredBy Admin? @relation("StatusChangesTriggered", fields: [triggeredById], references: [id])
  match       Match? @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt(sort: Desc)])
  @@index([newStatus])
  @@index([reason])
  @@map("player_status_change")
}

model AdminStatusChange {
  id      String @id @default(cuid())
  adminId String

  // Change details
  previousStatus AdminStatus
  newStatus      AdminStatus
  reason         StatusChangeReason
  notes          String?

  // Trigger
  triggeredById String?

  createdAt DateTime @default(now())

  // Relations
  admin       Admin  @relation("AdminStatusChanges", fields: [adminId], references: [id], onDelete: Cascade)
  triggeredBy Admin? @relation("AdminStatusChangesTriggered", fields: [triggeredById], references: [id])

  @@index([adminId, createdAt(sort: Desc)])
  @@index([newStatus])
  @@index([reason])
  @@map("admin_status_change")
}

// =============================================
// END INACTIVITY SYSTEM MODELS
// =============================================

// =============================================
// BUG TRACKING SYSTEM MODELS
// =============================================

model App {
  id          String  @id @default(cuid())
  code        String  @unique
  name        String  @unique
  displayName String
  description String?
  appUrl      String?
  logoUrl     String?
  isActive    Boolean @default(true)

  // Relations
  bugReports  BugReport[]
  bugModules  BugModule[]
  bugSettings BugReportSettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
  @@map("app")
}

model BugModule {
  id          String  @id @default(cuid())
  appId       String
  name        String
  code        String
  description String?
  isActive    Boolean @default(true)
  sortOrder   Int     @default(0)

  // Relations
  app        App         @relation(fields: [appId], references: [id], onDelete: Cascade)
  bugReports BugReport[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([appId, code])
  @@index([appId, isActive])
  @@map("bug_module")
}

model BugReport {
  id           String @id @default(cuid())
  reportNumber String @unique

  // Core fields
  title            String
  description      String
  moduleId         String
  reportType       BugReportType @default(BUG)
  severity         BugSeverity   @default(MEDIUM)
  stepsToReproduce String?
  expectedBehavior String?
  actualBehavior   String?

  // Admin-managed fields
  priority     BugPriority @default(NORMAL)
  status       BugStatus   @default(NEW)
  assignedToId String?

  // Auto-captured context
  appId            String
  pageUrl          String?
  userAgent        String?
  browserName      String?
  browserVersion   String?
  osName           String?
  osVersion        String?
  screenWidth      Int?
  screenHeight     Int?
  appVersion       String?
  sessionId        String?
  consoleErrors    Json?
  networkRequests  Json?
  localStorageData Json?

  // Reporter info (optional - for anonymous reports)
  reporterId     String?
  // Anonymous reporter info (when not logged in)
  anonymousEmail String?
  anonymousName  String?

  // Resolution
  resolvedById    String?
  resolvedAt      DateTime?
  resolutionNotes String?
  rootCause       String?
  timeToResolve   Int?

  // Tracking
  viewCount         Int     @default(0)
  duplicateOfId     String?
  externalTicketUrl String?
  isPublic          Boolean @default(false)

  // Google Sheets sync
  sheetSyncedAt DateTime?
  sheetRowId    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  app           App               @relation(fields: [appId], references: [id])
  module        BugModule         @relation(fields: [moduleId], references: [id])
  reporter      User?             @relation("BugReporter", fields: [reporterId], references: [id])
  assignedTo    Admin?            @relation("BugAssignee", fields: [assignedToId], references: [id])
  resolvedBy    Admin?            @relation("BugResolver", fields: [resolvedById], references: [id])
  duplicateOf   BugReport?        @relation("BugDuplicates", fields: [duplicateOfId], references: [id], onDelete: SetNull)
  duplicates    BugReport[]       @relation("BugDuplicates")
  screenshots   BugScreenshot[]
  comments      BugComment[]
  statusChanges BugStatusChange[]

  @@index([appId, status])
  @@index([appId, moduleId])
  @@index([reporterId])
  @@index([assignedToId])
  @@index([status, priority])
  @@index([createdAt(sort: Desc)])
  @@index([reportNumber])
  @@map("bug_report")
}

model BugScreenshot {
  id          String @id @default(cuid())
  bugReportId String

  // File info
  fileName     String
  fileSize     Int
  mimeType     String
  imageUrl     String
  thumbnailUrl String?

  // Metadata
  width   Int?
  height  Int?
  caption String?

  createdAt DateTime @default(now())

  // Relations
  bugReport BugReport @relation(fields: [bugReportId], references: [id], onDelete: Cascade)

  @@index([bugReportId])
  @@map("bug_screenshot")
}

model BugComment {
  id          String @id @default(cuid())
  bugReportId String
  authorId    String

  content    String
  isInternal Boolean @default(false)

  // Reply threading
  parentId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  bugReport BugReport    @relation(fields: [bugReportId], references: [id], onDelete: Cascade)
  author    User         @relation("BugCommentAuthor", fields: [authorId], references: [id])
  parent    BugComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies   BugComment[] @relation("CommentReplies")

  @@index([bugReportId, createdAt])
  @@index([authorId])
  @@map("bug_comment")
}

model BugStatusChange {
  id          String @id @default(cuid())
  bugReportId String

  previousStatus   BugStatus?
  newStatus        BugStatus
  previousPriority BugPriority?
  newPriority      BugPriority?
  changedById      String?
  notes            String?

  createdAt DateTime @default(now())

  // Relations
  bugReport BugReport @relation(fields: [bugReportId], references: [id], onDelete: Cascade)
  changedBy User?     @relation("BugStatusChanger", fields: [changedById], references: [id])

  @@index([bugReportId, createdAt(sort: Desc)])
  @@map("bug_status_change")
}

model BugReportSettings {
  id    String @id @default(cuid())
  appId String @unique

  // Feature toggles
  enableScreenshots    Boolean @default(true)
  enableAutoCapture    Boolean @default(true)
  enableConsoleCapture Boolean @default(true)
  enableNetworkCapture Boolean @default(false)
  maxScreenshots       Int     @default(5)
  maxFileSize          Int     @default(5242880)

  // Notifications
  notifyEmails         Json?
  slackWebhookUrl      String?
  discordWebhookUrl    String?
  notifyOnNew          Boolean @default(true)
  notifyOnStatusChange Boolean @default(true)

  // Google Sheets integration
  googleSheetId   String?
  googleSheetName String?
  syncEnabled     Boolean @default(false)

  // Defaults
  defaultAssigneeId String?
  defaultPriority   BugPriority @default(NORMAL)

  // Customization
  customFields Json?

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  // Relations
  app             App    @relation(fields: [appId], references: [id], onDelete: Cascade)
  defaultAssignee Admin? @relation("BugDefaultAssignee", fields: [defaultAssigneeId], references: [id])

  @@map("bug_report_settings")
}

// =============================================
// END BUG TRACKING SYSTEM MODELS
// =============================================

model Achievement {
  id          String              @id @default(cuid())
  title       String
  description String
  icon        String              // Ionicons name (e.g., "trophy", "flame", "star")

  // Classification
  category AchievementCategory
  tier     TierType             @default(BRONZE)
  scope    AchievementScope     @default(LIFETIME)

  // Evaluation
  evaluatorKey   String          // maps to hard-coded evaluator function name
  threshold      Int             @default(1) // target value (e.g., 10 for "Win 10 matches")
  sportFilter    SportType?      // null = all sports, or specific sport
  gameTypeFilter GameType?       // null = all, SINGLES, or DOUBLES

  // Display
  sortOrder Int     @default(0) // ordering within category
  isHidden  Boolean @default(false) // hidden until earned (surprise achievements)
  points    Int     @default(0)
  isActive  Boolean @default(true)

  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  userAchievements UserAchievement[]

  @@unique([evaluatorKey, sportFilter, gameTypeFilter, threshold])
  @@index([category])
  @@index([isActive])
  @@index([scope])
}

model UserAchievement {
  id            String    @id @default(cuid())
  userId        String
  achievementId String
  progress      Int       @default(0) // current value toward threshold
  isCompleted   Boolean   @default(false)
  unlockedAt    DateTime? // null until completed

  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId, isCompleted])
  @@index([achievementId])
}

model Thread {
  id        String  @id @default(cuid())
  name      String? // Only for group chats
  avatarUrl String?
  isGroup   Boolean @default(false)

  divisionId String?
  division   Division? @relation("DivisionThreads", fields: [divisionId], references: [id], onDelete: SetNull)

  members  UserThread[]
  messages Message[]

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  notifications Notification[]
}

model UserThread {
  id          String   @id @default(cuid())
  thread      Thread   @relation(fields: [threadId], references: [id])
  threadId    String
  user        User     @relation(fields: [userId], references: [id])
  unreadCount Int      @default(0)
  userId      String
  role        String?
  joinedAt    DateTime @default(now())

  @@unique([threadId, userId]) // Prevent duplicate memberships
  @@index([userId])
  @@index([threadId])
}

model Message {
  id       String @id @default(cuid())
  thread   Thread @relation(fields: [threadId], references: [id])
  threadId String
  sender   User   @relation(fields: [senderId], references: [id])
  senderId String

  content String?

  // Message Type (for different message types)
  messageType MessageType @default(TEXT)

  // For match posts in division chat
  matchId   String?
  matchData Json? // Store match details (type, format, location, etc.)
  match     Match?  @relation(fields: [matchId], references: [id], onDelete: SetNull)

  // Reply/Quote/Forwarding
  repliesToId String?
  repliesTo   Message?  @relation("Replies", fields: [repliesToId], references: [id], onDelete: SetNull)
  repliedBy   Message[] @relation("Replies")

  // Message Management
  isEdited  Boolean @default(false)
  isDeleted Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([threadId, createdAt])
  @@index([matchId])
}

model Friendship {
  id          String           @id @default(cuid())
  requesterId String
  recipientId String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  respondedAt DateTime?

  requester User @relation("SentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient User @relation("ReceivedFriendRequests", fields: [recipientId], references: [id], onDelete: Cascade)

  @@unique([requesterId, recipientId])
  @@index([requesterId])
  @@index([recipientId])
  @@index([status])
  @@map("friendship")
}

model Favorite {
  id          String   @id @default(cuid())
  userId      String // User who is making the favorite
  favoritedId String // User who is being favorited
  createdAt   DateTime @default(now())

  user      User @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
  favorited User @relation("FavoritedUser", fields: [favoritedId], references: [id], onDelete: Cascade)

  @@unique([userId, favoritedId])
  @@index([userId])
  @@index([favoritedId])
  @@map("favorite")
}

model PairRequest {
  id          String            @id @default(cuid())
  requesterId String
  recipientId String
  seasonId    String
  message     String?
  status      PairRequestStatus
  createdAt   DateTime          @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  requester     User           @relation("SentPairRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient     User           @relation("ReceivedPairRequests", fields: [recipientId], references: [id], onDelete: Cascade)
  season        Season         @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@index([requesterId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@index([recipientId, seasonId, status])
  @@index([requesterId, seasonId])
  @@map("pair_request")
}

model Partnership {
  id            String            @id @default(cuid())
  captainId     String // Requester = Captain (or remaining player for INCOMPLETE)
  partnerId     String? // Recipient = Partner (nullable for INCOMPLETE partnerships)
  seasonId      String
  divisionId    String?
  pairRating    Int?
  status        PartnershipStatus @default(ACTIVE)
  createdAt     DateTime          @default(now())
  dissolvedAt   DateTime?
  predecessorId String? // Links to dissolved partnership for standings inheritance

  captain           User                @relation("PartnershipCaptain", fields: [captainId], references: [id], onDelete: Cascade)
  partner           User?               @relation("PartnershipPartner", fields: [partnerId], references: [id], onDelete: Cascade)
  season            Season              @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  division          Division?           @relation(fields: [divisionId], references: [id], onDelete: SetNull)
  predecessor       Partnership?        @relation("PartnershipLineage", fields: [predecessorId], references: [id])
  successors        Partnership[]       @relation("PartnershipLineage")
  withdrawalRequest WithdrawalRequest[]
  notifications     Notification[]

  // Rating system relations
  divisionStandings DivisionStanding[]

  @@index([seasonId])
  @@index([status])
  @@index([captainId])
  @@index([partnerId])
  @@index([captainId, seasonId, status])
  @@index([partnerId, seasonId, status])
  @@index([predecessorId])
  @@map("partnership")
}

model SeasonInvitation {
  id          String                 @id @default(cuid())
  senderId    String
  recipientId String
  seasonId    String
  message     String?
  status      SeasonInvitationStatus
  createdAt   DateTime               @default(now())
  respondedAt DateTime?
  expiresAt   DateTime

  sender    User   @relation("SentSeasonInvitations", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User   @relation("ReceivedSeasonInvitations", fields: [recipientId], references: [id], onDelete: Cascade)
  season    Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  @@unique([senderId, recipientId, seasonId])
  @@index([senderId])
  @@index([recipientId])
  @@index([seasonId])
  @@index([status])
  @@map("season_invitation")
}

model Notification {
  id        String               @id @default(cuid())
  title     String?
  message   String
  category  NotificationCategory
  type      String?
  metadata  Json?
  createdAt DateTime             @default(now())

  seasonId            String?
  divisionId          String?
  matchId             String?
  userId              String?
  partnershipId       String?
  threadId            String?
  pairRequestId       String?
  withdrawalRequestId String?

  // Relations
  season            Season?            @relation(fields: [seasonId], references: [id])
  division          Division?          @relation(fields: [divisionId], references: [id])
  match             Match?             @relation(fields: [matchId], references: [id])
  user              User?              @relation(fields: [userId], references: [id])
  partnership       Partnership?       @relation(fields: [partnershipId], references: [id])
  thread            Thread?            @relation(fields: [threadId], references: [id])
  pairRequest       PairRequest?       @relation(fields: [pairRequestId], references: [id])
  withdrawalRequest WithdrawalRequest? @relation(fields: [withdrawalRequestId], references: [id])

  userNotifications UserNotification[]

  @@index([type])
  @@index([createdAt])
  @@map("notification")
}

model UserNotification {
  id             String    @id @default(cuid())
  userId         String
  notificationId String
  read           Boolean   @default(false)
  archive        Boolean   @default(false)
  readAt         DateTime?

  notification Notification @relation(fields: [notificationId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@unique([userId, notificationId])
  @@index([userId, read])
  @@index([userId, archive])
  @@map("user_notification")
}

model NotificationPreference {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Match notifications
  matchReminders   Boolean @default(true)
  matchRescheduled Boolean @default(true)
  matchCancelled   Boolean @default(true)
  matchResults     Boolean @default(true)
  partnerChange    Boolean @default(true)
  opponentChange   Boolean @default(true)

  // Rating/Performance
  ratingChange     Boolean @default(true)
  inactivityAlerts Boolean @default(true)

  // Social
  chatNotifications Boolean @default(true)
  invitations       Boolean @default(true)

  // Season
  seasonRegistration Boolean @default(true)
  seasonUpdates      Boolean @default(true)

  // Admin (for admin users)
  disputeAlerts      Boolean @default(true)
  teamChangeRequests Boolean @default(true)
  withdrawalRequests Boolean @default(true)
  playerReports      Boolean @default(true)
  seasonJoinRequests Boolean @default(true)

  // Delivery channels
  pushEnabled  Boolean @default(true)
  emailEnabled Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("notification_preference")
}

model UserPushToken {
  id           String    @id @default(cuid())
  userId       String
  token        String    @unique
  platform     String // "ios", "android", "web"
  deviceId     String? // Optional device identifier for multi-device support
  isActive     Boolean   @default(true)
  failureCount Int       @default(0) // Track consecutive failures for cleanup
  lastUsedAt   DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([platform])
  @@index([isActive])
  @@map("user_push_token")
}

// System Maintenance Schedule
model SystemMaintenance {
  id               String            @id @default(cuid())
  title            String
  description      String?           @db.Text
  startDateTime    DateTime
  endDateTime      DateTime
  status           MaintenanceStatus @default(SCHEDULED)
  affectedServices String[] // Array of services that will be affected
  notificationSent Boolean           @default(false)
  completionSent   Boolean           @default(false)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@index([startDateTime])
  @@index([endDateTime])
  @@index([status])
  @@map("system_maintenance")
}

// Feature Announcements
model FeatureAnnouncement {
  id               String                    @id @default(cuid())
  title            String
  description      String                    @db.Text
  featureDetails   Json? // Additional details about the feature
  releaseDate      DateTime?
  announcementDate DateTime                  @default(now())
  status           FeatureAnnouncementStatus @default(DRAFT)
  targetAudience   String[] // Array of user roles or "ALL"
  notificationSent Boolean                   @default(false)
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt

  @@index([status])
  @@index([announcementDate])
  @@map("feature_announcement")
}

// Audit log for admin messages to participants
model AdminMessageLog {
  id           String   @id @default(cuid())
  adminId      String
  matchId      String?
  seasonId     String?
  subject      String
  message      String   @db.Text
  recipientIds String[] // Array of user IDs who received the message

  // Delivery options
  sendEmail Boolean @default(false)
  sendPush  Boolean @default(false)

  // Delivery results
  inAppCount   Int @default(0)
  emailCount   Int @default(0)
  emailSkipped Int @default(0)
  pushCount    Int @default(0)
  pushSkipped  Int @default(0)

  createdAt DateTime @default(now())

  admin Admin  @relation(fields: [adminId], references: [id])
  match Match? @relation(fields: [matchId], references: [id])

  @@index([adminId])
  @@index([matchId])
  @@index([createdAt])
  @@map("admin_message_log")
}

enum NotificationCategory {
  DIVISION
  LEAGUE
  CHAT
  MATCH
  SEASON
  PAYMENT
  ADMIN
  GENERAL
}

enum PairRequestStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
  AUTO_DENIED
}

enum PartnershipStatus {
  ACTIVE
  INCOMPLETE // Partnership missing a partner, awaiting replacement
  DISSOLVED
  EXPIRED
}

enum Role {
  USER
  ADMIN
  SUPERADMIN
}

enum AdminStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

model Payment {
  id                 String        @id @default(cuid())
  orderId            String        @unique
  amount             Decimal       @db.Decimal(10, 2)
  currency           String        @default("MYR")
  paymentMethod      String?
  status             PaymentStatus @default(PENDING)
  paidAt             DateTime?
  userId             String?
  seasonId           String?
  seasonMembershipId String?
  fiuuTransactionId  String?
  fiuuChannel        String?
  fiuuStatusCode     String?
  fiuuMessage        String?
  verificationHash   String?
  metadata           Json?
  notes              String?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  user             User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  season           Season?           @relation(fields: [seasonId], references: [id], onDelete: SetNull)
  seasonMembership SeasonMembership? @relation(fields: [seasonMembershipId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([seasonId])
  @@index([seasonMembershipId])
  @@index([status])
  @@index([userId, status])
  @@map("payment")
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  BANNED
  DELETED
}

// Admin action types for general admin logging
enum AdminActionType {
  // Player management
  PLAYER_BAN
  PLAYER_UNBAN
  PLAYER_DELETE
  PLAYER_UPDATE
  PLAYER_STATUS_CHANGE
  // League management
  LEAGUE_CREATE
  LEAGUE_UPDATE
  LEAGUE_DELETE
  LEAGUE_STATUS_CHANGE
  // Season management
  SEASON_CREATE
  SEASON_UPDATE
  SEASON_DELETE
  SEASON_STATUS_CHANGE
  // Division management
  DIVISION_CREATE
  DIVISION_UPDATE
  DIVISION_DELETE
  // Match management
  MATCH_VOID
  MATCH_EDIT_RESULT
  MATCH_EDIT_SCHEDULE
  MATCH_WALKOVER
  // Dispute management
  DISPUTE_RESOLVE
  DISPUTE_OVERRIDE
  // System settings
  SETTINGS_UPDATE
  // Bug reports
  BUG_ASSIGN
  BUG_RESOLVE
  BUG_UPDATE
  // Admin management
  ADMIN_CREATE
  ADMIN_UPDATE
  ADMIN_DELETE
  ADMIN_SUSPEND
  ADMIN_ACTIVATE
  // Payment management
  PAYMENT_STATUS_UPDATE
  PAYMENT_BULK_UPDATE
  // Other
  OTHER
}

// Target types for admin logging
enum AdminTargetType {
  PLAYER
  LEAGUE
  SEASON
  DIVISION
  MATCH
  DISPUTE
  SETTINGS
  BUG_REPORT
  ADMIN
  PAYMENT
  OTHER
}

enum UserActionType {
  MATCH_CREATE
  MATCH_JOIN
  MATCH_CANCEL
  MATCH_LEAVE
  SCORE_SUBMIT
  SCORE_CONFIRM
  SCORE_DISPUTE
  WALKOVER_REPORT
  WALKOVER_CONFIRM
  PAIR_REQUEST_SEND
  PAIR_REQUEST_ACCEPT
  PAIR_REQUEST_DENY
  PARTNERSHIP_DISSOLVE
  SEASON_REGISTER
  SEASON_WITHDRAW
  INVITATION_RESPOND_ACCEPT
  INVITATION_RESPOND_DECLINE
  PAYMENT_COMPLETE
  PAYMENT_FAIL
}

enum UserTargetType {
  MATCH
  SEASON
  PARTNERSHIP
  INVITATION
  PAYMENT
}

enum SeasonStatus {
  UPCOMING
  ACTIVE
  FINISHED
  CANCELLED
}

enum GenderRestriction {
  MALE
  FEMALE
  MIXED
  OPEN
}

enum GenderType {
  MALE
  FEMALE
  MIXED
  OPEN
}

enum MembershipStatus {
  PENDING
  ACTIVE
  FLAGGED
  INACTIVE
  REMOVED
}

enum Statuses {
  ACTIVE
  INACTIVE
  SUSPENDED
  UPCOMING
  ONGOING
  FINISHED
  CANCELLED
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TeamChangeRequestStatus {
  PENDING
  APPROVED
  DENIED
  CANCELLED
}

enum DivisionLevel {
  BEGINNER
  IMPROVER
  INTERMEDIATE
  UPPER_INTERMEDIATE
  EXPERT
  ADVANCED
}

enum GameType {
  SINGLES
  DOUBLES
}

enum SportType {
  PADEL
  PICKLEBALL
  TENNIS
}

// Self-assessed skill levels for sports (used during onboarding)
enum SkillLevel {
  BEGINNER
  IMPROVER
  INTERMEDIATE
  UPPER_INTERMEDIATE
  ADVANCED
  EXPERT
}

enum TierType {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum AchievementCategory {
  COMPETITION // wins, streaks, match milestones
  RATING // DMR rating milestones
  SEASON // division champion, top 3, participation
  SOCIAL // partnerships, multi-sport, community
}

enum AchievementScope {
  MATCH // evaluate after each match completion
  SEASON // evaluate at season end / standings update
  LIFETIME // evaluate on any relevant event
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

enum SeasonInvitationStatus {
  PENDING
  ACCEPTED
  DENIED
  CANCELLED
  EXPIRED
}

// =============================================
// ADMIN-FOCUSED MATCH MANAGEMENT ENUMS
// =============================================

enum MatchStatus {
  DRAFT // Match created but invitations expired/declined - can be edited
  SCHEDULED
  ONGOING
  COMPLETED
  UNFINISHED
  CANCELLED
  VOID
}

enum MatchReportCategory {
  FAKE_MATCH // Match appears to be fabricated
  RATING_MANIPULATION // Match used to manipulate ratings
  INAPPROPRIATE_CONTENT
  HARASSMENT
  SPAM
  OTHER
}

enum DisputeCategory {
  WRONG_SCORE
  NO_SHOW
  BEHAVIOR
  OTHER
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  REJECTED
}

enum DisputePriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum DisputeResolutionAction {
  UPHOLD_ORIGINAL
  UPHOLD_DISPUTER
  CUSTOM_SCORE
  VOID_MATCH
  AWARD_WALKOVER
  REQUEST_MORE_INFO
  REJECT // Dismiss dispute as invalid/spam/insufficient evidence
}

enum WalkoverReason {
  NO_SHOW
  LATE_CANCELLATION
  INJURY
  PERSONAL_EMERGENCY
  OTHER
}

enum PenaltyType {
  WARNING
  POINTS_DEDUCTION
  SUSPENSION
  NONE
}

enum PenaltySeverity {
  WARNING
  POINTS_DEDUCTION
  SUSPENSION
  PERMANENT_BAN
}

enum PenaltyStatus {
  ACTIVE
  APPEALED
  OVERTURNED
  EXPIRED
  COMPLETED
}

enum MatchAdminActionType {
  EDIT_RESULT
  VOID_MATCH
  CONVERT_TO_WALKOVER
  OVERRIDE_DISPUTE
  APPLY_PENALTY
  REMOVE_PARTICIPANT
  ADD_PARTICIPANT
  APPROVE_LATE_CANCELLATION
  DENY_LATE_CANCELLATION
  EDIT_SCHEDULE
  // Friendly match moderation
  HIDE_MATCH
  UNHIDE_MATCH
  REPORT_ABUSE
  CLEAR_REPORT
}

// =============================================
// END ADMIN-FOCUSED MATCH MANAGEMENT ENUMS
// =============================================

// =============================================
// RATING SYSTEM ENUMS
// =============================================

enum RatingChangeReason {
  MATCH_WIN
  MATCH_LOSS
  WALKOVER_WIN
  WALKOVER_LOSS
  MANUAL_ADJUSTMENT
  RECALCULATION
  INITIAL_PLACEMENT
  SEASON_RESET
}

enum AdjustmentType {
  MIGRATION
  CORRECTION
  APPEAL_RESOLUTION
  ADMIN_OVERRIDE
  OTHER
}

enum RecalculationScope {
  MATCH
  PLAYER
  DIVISION
  SEASON
  LEAGUE
}

enum RecalculationStatus {
  PENDING
  GENERATING_PREVIEW
  PREVIEW_READY
  APPLYING
  APPLIED
  FAILED
  CANCELLED
}

// =============================================
// END RATING SYSTEM ENUMS
// =============================================

// =============================================
// INACTIVITY SYSTEM ENUMS
// =============================================

enum StatusChangeReason {
  INACTIVITY_THRESHOLD
  INACTIVITY_WARNING
  MATCH_PLAYED
  ADMIN_MANUAL
  ADMIN_BAN
  ADMIN_UNBAN
  ADMIN_DELETE
  ADMIN_SUSPEND
  ADMIN_ACTIVATE
  SEASON_START
  SEASON_END
  REGISTRATION
  WITHDRAWAL
}

// =============================================
// END INACTIVITY SYSTEM ENUMS
// =============================================

// =============================================
// BUG TRACKING SYSTEM ENUMS
// =============================================

enum BugReportType {
  BUG
  FEEDBACK
  SUGGESTION
  QUESTION
  IMPROVEMENT
}

enum BugSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum BugPriority {
  URGENT
  HIGH
  NORMAL
  LOW
}

enum BugStatus {
  NEW
  TRIAGED
  IN_PROGRESS
  NEEDS_INFO
  IN_REVIEW
  RESOLVED
  CLOSED
  WONT_FIX
  DUPLICATE
}

// =============================================
// END BUG TRACKING SYSTEM ENUMS
// =============================================

// =============================================
// MATCH INVITATION SYSTEM ENUMS
// =============================================

enum MatchFormat {
  STANDARD // Best of 3 sets
  ONE_SET // Single set match
}

enum MatchType {
  SINGLES
  DOUBLES
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
  CANCELLED
}

enum ParticipantRole {
  CREATOR // User who created the match
  OPPONENT // Direct opponent (singles) or opposing team
  PARTNER // Doubles partner
  INVITED // General invitee
}

enum CancellationReason {
  PERSONAL_EMERGENCY
  INJURY
  WEATHER
  SCHEDULING_CONFLICT
  ILLNESS
  WORK_COMMITMENT
  FAMILY_EMERGENCY
  OTHER
}

enum TimeSlotStatus {
  PROPOSED
  VOTED
  CONFIRMED
  REJECTED
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  DENIED
  CANCELLED // Requester cancelled
  EXPIRED // Match filled or cancelled
}

enum MessageType {
  TEXT // Regular text message
  MATCH // Match Events posted to division chat
  SYSTEM // System messages (user joined, etc.)
  JOIN_REQUEST // Join request notification
}

enum MatchFeeType {
  FREE // No fee required
  SPLIT // Cost is split among participants
  FIXED // Fixed fee per participant
}

// =============================================
// END MATCH INVITATION SYSTEM ENUMS
// =============================================

// =============================================
// FINALS BRACKET SYSTEM ENUMS
// =============================================

enum BracketType {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
}

enum BracketStatus {
  DRAFT
  SEEDED
  PUBLISHED
  IN_PROGRESS
  COMPLETED
}

enum SeedingSource {
  STANDINGS
  MANUAL
  RATING
}

enum BracketMatchStatus {
  PENDING
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  BYE
}

// =============================================
// END FINALS BRACKET SYSTEM ENUMS
// =============================================

// =============================================
// SYSTEM NOTIFICATIONS ENUMS
// =============================================

enum MaintenanceStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum FeatureAnnouncementStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

// =============================================
// END SYSTEM NOTIFICATIONS ENUMS
// =============================================

// =============================================
// ACTIVITY FEED MODELS
// =============================================

model FeedPost {
  id        String  @id @default(cuid())
  matchId   String
  authorId  String
  caption   String? @db.VarChar(500)
  sport     String // tennis, padel, pb
  matchType String // singles, doubles
  gameType  String // league, friendly

  // Denormalized match data for fast reads
  winnerIds  String[] // Array of winner user IDs
  loserIds   String[] // Array of loser user IDs
  matchDate  DateTime
  leagueId   String?  // League reference (if league game)
  divisionId String?  // Division reference (if league game)

  // Counters (denormalized for performance)
  likeCount    Int @default(0)
  commentCount Int @default(0)

  // Soft delete
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  match    Match         @relation(fields: [matchId], references: [id])
  author   User          @relation("FeedPostAuthor", fields: [authorId], references: [id])
  likes    FeedLike[]
  comments FeedComment[]

  @@index([authorId])
  @@index([matchId])
  @@index([sport])
  @@index([createdAt])
  @@index([isDeleted, createdAt])
}

model FeedLike {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  post FeedPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User     @relation("FeedLikeUser", fields: [userId], references: [id])

  @@unique([postId, userId]) // One like per user per post
  @@index([postId])
  @@index([userId])
}

model FeedComment {
  id       String @id @default(cuid())
  postId   String
  authorId String
  text     String @db.VarChar(200)

  // Soft delete
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  post   FeedPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  author User     @relation("FeedCommentAuthor", fields: [authorId], references: [id])

  @@index([postId])
  @@index([authorId])
  @@index([postId, isDeleted, createdAt])
}

// =============================================
// END ACTIVITY FEED MODELS
// =============================================

// =============================================
// BEST 6 SCORING SYSTEM ENUMS
// =============================================

enum TiebreakType {
  STANDARD_7PT // Standard 7-point tiebreak (Sets 1 & 2)
  MATCH_10PT // Match tiebreak (Set 3 default, or Set 3 at 6-6)
}

enum Set3Format {
  MATCH_TIEBREAK // Default: 10-point match tiebreak
  FULL_SET // Optional: Full standard set (6-6 â†’ match tiebreak)
}

// =============================================
// END BEST 6 SCORING SYSTEM ENUMS
// =============================================

// =============================================
// ONBOARDING STEP TRACKING ENUM
// =============================================

enum OnboardingStep {
  PERSONAL_INFO // Step 1: Name, Gender, DOB completed
  LOCATION // Step 2: Location completed
  GAME_SELECT // Step 3: Sport selection completed
  SKILL_ASSESSMENT // Step 4: Questionnaire completed
  ASSESSMENT_RESULTS // Step 5: Results viewed
  PROFILE_PICTURE // Step 6: Final step (profile picture uploaded/skipped)
}

// =============================================
// END ONBOARDING STEP TRACKING ENUM
// =============================================
